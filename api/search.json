[{"id":"e38905ad1968dd93d6be591395b50e19","title":"Start","content":"谨以此站记录本人知识积累Stay hungry        Stay foolish","slug":"strat","date":"3333-03-27T05:48:25.000Z","categories_index":"Begin","tags_index":"","author_index":"Hubert"},{"id":"7c23f20e9197b6064d9ced0e7cb118d0","title":"golang-基础","content":"Golang基础语法概述\nGo语言也称为 Golang，是由 Google 公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。 \n特点：\n语法简单\n并发模型\nGo语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。\n\n\n内存分配\n垃圾回收\n静态链接\n标准库\n工具链\n\n\n\n数据类型\n注意事项：\n\n关于别名\n可以理解为一种变量类型取了个别名\nbyte  alias for uint8\nrune alias for  int32\n\n\n底层数据结构相等并不意味着就是别名\n比如不同平台的int和int64或int32还是需要类型转换\n\n\n\n\n\n\n分类标准一\n\n布尔型\n\n数值型\n\n整形\n\nint和uint  \n它们分别对应特定 CPU 平台的字长（机器字大小），其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化。\n\n\n无符号 uint8       uint16          uint32    uint64\n​有符号 int8          int16            int32        int64\n\n\n浮点\n\nfloat32  大约 6 个十进制数的精度 \nfloat64   大约 15 个十进制数的精度\n\n\n复数\n\ncomplex128（64 位实数和虚数） \n\ncomplex64（32 位实数和虚数） \nvar name complex128 &#x3D; complex(x, y)\n\n\n\n\n字符串\n\n派生类型\n\n(a) 指针类型（Pointer）\n(b) 数组类型\n(c) 结构体类型(struct)\n(d) Channel 类型\n(e) 函数类型\n(f) 切片类型\n(g) 接口类型（interface）\n(h) Map 类型\n\n\n\n\n分类标准二：\n\n非引用类型：\n包含int、float、bool、string、struct、数组\n\n\n引用类型\nmap、slice、channel、interface\n\n\n\n\n\n量变量（var）\n变量类型   （Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。）\n\n局部变量\n\n声明了必须使用，未被声明会报错，在函数体内定义。\n\n\n全局变量\n\n声明了可以不用使用，全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。\n\n\n\n\n声明变量\nvar xxx， xxx 变量类型\n\nvar vname1, vname2, vname3 &#x3D; v1, v2, v3 &#x2F;&#x2F; 和 python 很像,不需要显示声明类型，自动推断\n\nf :&#x3D; &quot;Runoob&quot;         &#x2F;&#x2F; ！！！这种不带声明格式的只能在函数体中出现\n&#x2F;&#x2F;关于简短模式的注意事项\n&#x2F;&#x2F; 1.简短模式不是简单的赋值，而是一种简短的定义变量和赋值操作\n&#x2F;&#x2F; 2.简短模式在同一个作用域下会退化为赋值操作，不同作用域下为原功能\n\nvar (                &#x2F;&#x2F; 这种因式分解关键字的写法一般用于声明全局变量\n    a int\n    b bool\n)\n\n变量初始值\n\n数值                   0\n布尔                 false\n字符串              “”(空字符串)\n派生类型          nil\n\n\n匿名变量\n\n“_” 本身就是一个特殊的标识符，被称为空白标识符。\n空标识符可用来临时规避编译器对未使用变量和导入包的错误检查。但请注意，它是预置成员,不能重新定义。\n\n\n命名注意事项\n\n符号名字首字母大小写决定了其作用域。首字母大写的为导出成员，可被包外引用，而小写则仅能在包内使用。\n\n\n\n常量（const）\n声明常量\nconst xxxx &#x3D; xxx\nconst xxxx 类型 &#x3D; xxx\nconst （\n    xxx 类型\n    xxx 类型\n）\n\niota\n\n就是每个常量行建立的索引值\n&#x2F;&#x2F;iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次\nfunc main() &#123;\n    const (\n            a &#x3D; iota   &#x2F;&#x2F;0\n            b          &#x2F;&#x2F;1\n            c          &#x2F;&#x2F;2\n            d &#x3D; &quot;ha&quot;   &#x2F;&#x2F;独立值，iota +&#x3D; 1\n            e          &#x2F;&#x2F;&quot;ha&quot;   iota +&#x3D; 1\n            f &#x3D; 100    &#x2F;&#x2F;iota +&#x3D;1\n            g          &#x2F;&#x2F;100  iota +&#x3D;1\n            h &#x3D; iota   &#x2F;&#x2F;7,恢复计数\n            i          &#x2F;&#x2F;8\n    )\n    fmt.Println(a,b,c,d,e,f,g,h,i)\n&#125;\n\n\n\n自定义量 （type）type 变量名称 变量类型\n\n\n\n\n\n\n\n\n\n运算符号\n*和  &amp;  （理解）\n&amp;：取变量的地址值\n*：取地址值的变量\nfunc main()&#123;\n    var a int &#x3D; 4\n    var ptr int\n    ptr &#x3D; a \n    fmt.Println(ptr)&#x2F;&#x2F;4\n    a &#x3D; 15\n    fmt.Println(ptr)&#x2F;&#x2F;4\n    \n    var b int &#x3D; 5 \n    var ptr1 *int\n    ptr1 &#x3D; &amp;b \n    fmt.Println(*ptr1)&#x2F;&#x2F;5\n    b&#x3D;15 \n    fmt.Println(*ptr1)&#x2F;&#x2F;15\n&#125;\n\n流程控制：条件语句\nif\n\n注意事项：基于重构原则，应该保持代码块的逻辑单一\n\nif 布尔表达式 &#123;\n   &#x2F;* 在布尔表达式为 true 时执行 *&#x2F;\n&#125; else &#123;\n  &#x2F;* 在布尔表达式为 false 时执行 *&#x2F;\n&#125;\n\n\n&#x2F;&#x2F;if 的表达式前可以添加语句或执行初始化,该语句声明的变量作用域仅在 if 和 else 之内。\nif v :&#x3D; 10; v &gt;9&#123;\n\t\tfmt.Println(v)\n&#125;\n\nswitch\nswitch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。 \nfunc main() &#123;\n   &#x2F;* 定义局部变量 *&#x2F;\n   var grade string &#x3D; &quot;B&quot;\n   var marks int &#x3D; 90\n\n   switch marks &#123;\n      case 90: grade &#x3D; &quot;A&quot;\n      case 80: grade &#x3D; &quot;B&quot;\n      case 50,60,70 : grade &#x3D; &quot;C&quot;\n      default: grade &#x3D; &quot;D&quot;                 &#x2F;&#x2F;default只有全部没有匹配成功时才会使用\n   &#125;\n\n   switch &#123;\n      case grade &#x3D;&#x3D; &quot;A&quot; :\n         fmt.Printf(&quot;优秀!\\n&quot; )    \n      case grade &#x3D;&#x3D; &quot;B&quot;, grade &#x3D;&#x3D; &quot;C&quot; :\n         fmt.Printf(&quot;良好\\n&quot; )      \n      case grade &#x3D;&#x3D; &quot;D&quot; :\n         fmt.Printf(&quot;及格\\n&quot; )      \n      case grade &#x3D;&#x3D; &quot;F&quot;:\n         fmt.Printf(&quot;不及格\\n&quot; )\n      default:\n         fmt.Printf(&quot;差\\n&quot; );\n   &#125;\n   fmt.Printf(&quot;你的等级是 %s\\n&quot;, grade );      \n&#125;\n\n循环语句\nfor语句\nfunc main() &#123;\n        sum :&#x3D; 0\n        &#x2F;&#x2F;标准形式\n        for i :&#x3D; 0; i &lt;&#x3D; 10; i++ &#123;\n                sum +&#x3D; i\n        &#125;\n        fmt.Println(sum)\n\n        &#x2F;&#x2F; 这样写也可以，更像 While 语句形式\n        for sum &lt;&#x3D; 10&#123;\n                sum +&#x3D; sum\n        &#125;\n        fmt.Println(sum)\n       &#x2F;&#x2F; 无限循环模式\n        for &#123;\n           \n        &#125;\n    \n    \n&#125;\n\n\n注意事项\n初始化语句仅被执行一次。条件表达式中如有函数调用，须确认是否会重复执行。可能会被编译器优化掉,也可能是动态结果须每次执行确认。\n\n\n\n\nfor range语句\nfor index, value :&#x3D; range xxxx&#123;\n    \n&#125;\n&#x2F;&#x2F;可以遍历索引和值，_可以替代为空\n\n关键字\n\ngoto（无条件转移行）\n在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 \n\nbreak（结束循环）\n\ncontinue（重新开始循环）\n\n\n\n\n关键字\ndefer（延迟执行语句）\n\n理解：类似于java中的finnaly，defer标注的语句会在函数最后执行，如果有多个defer语句，他们之间的顺序是逆序的，类似于栈的先进后出\nfunc main() &#123;\n    fmt.Println(&quot;defer begin&quot;)\n    &#x2F;&#x2F; 将defer放入延迟调用栈\n    defer fmt.Println(1)\n    defer fmt.Println(2)\n    &#x2F;&#x2F; 最后一个放入, 位于栈顶, 最先调用\n    defer fmt.Println(3)\n    fmt.Println(&quot;defer end&quot;)\n&#125;\n\n\n\n数据类型集合数组\n是什么？\n\n是一种数据结构\n\n\n特点：\n\n元素类型一致\n长度固定\n元素值可以修改\n\n\n使用\n\n定义\n&#x2F;&#x2F;定义数组\nvar balance [10] float32\n&#x2F;&#x2F;定义并初始化\nvar balance &#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F;定义并初始化时，可以用... 代替长度\nvar balance &#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n或\nbalance :&#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n\n访问\n\n通过数组索引进行访问\n\n\n\n\n多维数组\n\n初始化\na :&#x3D; [3][4]int&#123;  \n &#123;0, 1, 2, 3&#125; ,   &#x2F;*  第一行索引为 0 *&#x2F;\n &#123;4, 5, 6, 7&#125; ,   &#x2F;*  第二行索引为 1 *&#x2F;\n &#123;8, 9, 10, 11&#125;&#125;   &#x2F;* 第三行索引为 2 *&#x2F;\n\n访问（通过循环角标）\n&#x2F;* 输出数组元素 *&#x2F;\n   for  i &#x3D; 0; i &lt; 5; i++ &#123;\n      for j &#x3D; 0; j &lt; 2; j++ &#123;\n         fmt.Printf(&quot;a[%d][%d] &#x3D; %d\\n&quot;, i,j, a[i][j] )\n      &#125;\n   &#125;\n\n\n\n切片\n基本概念\n\n俗称  “动态数组”，可以简单的理解为长度可以变化的数组\n实际上是一种特殊的数据结构，切片并不存储任何数据，它只是描述了底层数组中的一段。 \n理解：\n切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片\n\n\n\n三要素：\n\n指针\n长度\n容量\n\n\n创建和初始化切片\n\n通过对已存在的数组进行相关截断\nlist :&#x3D; [...]int&#123;1,2,3,4&#125;\nslice :&#x3D; list[1,3]\n\n通过字面量创建（本质上和第一种原理相同，只不过是数组的全引用）&#x2F;&#x2F; 创建字符串切片\n&#x2F;&#x2F; 其长度和容量都是 3 个元素\nmyStr :&#x3D; []string&#123;&quot;Jack&quot;, &quot;Mark&quot;, &quot;Nick&quot;&#125;\n&#x2F;&#x2F; 创建一个整型切片\n&#x2F;&#x2F; 其长度和容量都是 4 个元素\nmyNum :&#x3D; []int&#123;10, 20, 30, 40&#125;\n var numbers []int\n\n通过make方法(一般用于创建切片)\nslice :&#x3D; make([]int, len,volume)\n&#x2F;&#x2F;容量通常为底层数组的长度\n\n注意：\n\n方法1和2,3最大的区别是底层数组的对外暴露问题，方法2,3只能通过slice来编辑底层数组，而方法1可以用原来数组的名来引用\n\n\n\n\n动态增长特性\n\nappend在追加时，如果容量不够，则会在底层创建新的数组，所以限制切片赋值时的容量大小（len&#x3D;cap）可以有效的避免该问题（重难点）\n\n\n相关操作\n\n遍历\nmyNum :&#x3D; []int&#123;10, 20, 30, 40, 50&#125;\n&#x2F;&#x2F; 从第三个元素开始迭代每个元素\nfor index :&#x3D; 2; index &lt; len(myNum); index++ &#123;\n    ...\n&#125;\n\n拷贝\nnum1 :&#x3D; []int&#123;10, 20, 30&#125;\nnum2 :&#x3D; make([]int, 5)\ncount :&#x3D; copy(num2, num1)\nfmt.Println(count)\nfmt.Println(num2)\n&#x2F;&#x2F;结果\n\n3\n[10 20 30 0 0]\n\n增加\nslice &#x3D; apppend(slice, new_slice...)\n\n\n\nMap\n是什么\n\n就是字典，用来存储键值对\n\n\n底层结构\n\n可以类比java中的map，key是不可重复的\n\n\n初始化\nvar mapname map[keytype]valuetype &#x3D; map[keytype]valuetype&#123;key:value, key:value&#125;\n\nmapname :&#x3D; map[keytype]valuetype&#123;key:value, key:value&#125;\n\nmapname :&#x3D; make(map[keytype]valuetype)\n\n相关操作\n\n删除\ndelete(k,v)\n\n增加和修改\nmap[k]&#x3D;v\n&#x2F;&#x2F;如果k存在，则是修改，如果不存在，则是增加\n\n\n切片map\n\n个人感觉语法很怪，暂时没有深入了解\n\n\n\n指针\n是什么\n\n本质上也是一个变量，只不过存储变量的地址值，一个指针变量指向了一个值的内存地址。\n\n\n基础操作\nfunc main() &#123;\n   var a int&#x3D; 20   &#x2F;* 声明实际变量 *&#x2F;\n   var ip *int        &#x2F;* 声明指针变量 *&#x2F;\n\n   ip &#x3D; &amp;a  &#x2F;* 指针变量的存储地址 *&#x2F;\n\n   fmt.Printf(&quot;a 变量的地址是: %x\\n&quot;, &amp;a  )\n\n   &#x2F;* 指针变量的存储地址 *&#x2F;\n   fmt.Printf(&quot;ip 变量储存的指针地址: %x\\n&quot;, ip )\n\n   &#x2F;* 使用指针访问值 *&#x2F;\n   fmt.Printf(&quot;*ip 变量的值: %d\\n&quot;, *ip )\n\n\n*: 声明为变量指针，为指针变量赋值只能赋地址值\n*加上指针变量用来访问指针变量中指向地址的值。\n\n\n指针数组\n\n就是用来存放多个地址的数据结构\n\nfunc main() &#123;\n   a :&#x3D; []int&#123;10,100,200&#125;\n   var i int\n   var ptr [MAX]*int;\n\n   for  i &#x3D; 0; i &lt; MAX; i++ &#123;\n      ptr[i] &#x3D; &amp;a[i] &#x2F;* 整数地址赋值给指针数组 *&#x2F;\n   &#125;\n\n   for  i &#x3D; 0; i &lt; MAX; i++ &#123;\n      fmt.Printf(&quot;a[%d] &#x3D; %d\\n&quot;, i,*ptr[i] )\n   &#125;\n&#125;\n\n\n\n指针的指针\nvar a int\n   var ptr *int\n   var pptr **int\n\n   a &#x3D; 3000\n\n   &#x2F;* 指针 ptr 地址 *&#x2F;\n   ptr &#x3D; &amp;a\n\n   &#x2F;* 指向指针 ptr 地址 *&#x2F;\n   pptr &#x3D; &amp;ptr\n\n   &#x2F;* 获取 pptr 的值 *&#x2F;\n   fmt.Printf(&quot;变量 a &#x3D; %d\\n&quot;, a )\n   fmt.Printf(&quot;指针变量 *ptr &#x3D; %d\\n&quot;, *ptr )\n   fmt.Printf(&quot;指向指针的指针变量 **pptr &#x3D; %d\\n&quot;, **pptr)\n\n函数\nGo语言里面拥三种类型的函数：\n普通的带有名字的函数\n匿名函数或者 lambda 函数(闭包)\n方法\n\n\n普通函数定义和操作\n\n&#x2F;* 函数返回两个数的最大值 *&#x2F;\nfunc max(num1, num2 int) （int） &#123;\n   &#x2F;* 声明局部变量 *&#x2F;\n   var result int\n\n   if (num1 &gt; num2) &#123;\n      result &#x3D; num1\n   &#125; else &#123;\n      result &#x3D; num2\n   &#125;\n   return result\n&#125;\n\n\n匿名函数\n定义：匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成 （没有名字的普通函数）\n\n特点：\n\n动态创建（和普通函数最大的区别）,并且可以作为返回值\n\n\n常见操作\n\n在定义时调用匿名函数\nfunc(data int) &#123;\n    fmt.Println(&quot;hello&quot;, data)\n&#125;(100)\n\n将匿名函数赋值给变量\n\n\n&#x2F;&#x2F; 将匿名函数体保存到f()中\nf :&#x3D; func(data int) &#123;\n    fmt.Println(&quot;hello&quot;, data)\n&#125;\n&#x2F;&#x2F; 使用f()调用\nf(100)\n\n\n匿名函数用作回调函数\n&#x2F;&#x2F; 遍历切片的每个元素, 通过给定函数进行元素访问\nfunc visit(list []int, f func(int)) &#123;\n    for _, v :&#x3D; range list &#123;\n        f(v)\n    &#125;\n&#125;\nfunc main() &#123;\n    &#x2F;&#x2F; 使用匿名函数打印切片内容\n    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;\n        fmt.Println(v)\n    &#125;)\n&#125;\n\n\n\n\n闭包\n概述：\n\n闭包是函数的一种高级应用\n因为匿名函数是动态创建的，所以可以直接调用外部的变量，而不是像普通函数通过参数传递变量\n\n\n理解：\n\n为什么叫做闭包。首先可以理解为一个封闭的包，而包的特点就是可以调用包内的变量，匿名函数和它引用的变量以及环境，类似常规函数引用全局变量处于一个包的环境。\n\n\n闭包 &#x3D; 匿名函数 + 当前环境\nfunc main() &#123;\n\tn :&#x3D; 0\n\tf :&#x3D; func() int &#123;\n\t\tn +&#x3D; 1\n\t\treturn n\n\t&#125;\n\tfmt.Println(f())  &#x2F;&#x2F; 别忘记括号，不加括号相当于地址\n\tfmt.Println(f())\n&#125;\n\n闭包作为返回值\nfunc Increase() func() int &#123;\n\tn :&#x3D; 0\n\treturn func() int &#123;\n\t\tn++\n\t\treturn n\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\tin :&#x3D; Increase()\n\tfmt.Println(in())\n\tfmt.Println(in())\n&#125;\n\n\n\n方法\n定义\n\n类比java中的方法，因为go没有对象，而结构体内无法定义方法，所以采用在函数上添加特定结构体接收者的办法创建方法\n总结：            方法就是一类带特殊的 接收者 参数的函数。\n\n\n注意事项\n\n方法就是个函数，和java中不一样，不要当对象的方法来使用\n\n指针接受者（接受者的类型前添加*，会指向原对象，而值接收者只会对副本进行操作）\n&#x2F;&#x2F;指针接收者\ntype person struct &#123;\n\t name string\n\t age int8\n&#125;\n\nfunc (p *person) setName(name string) &#123;\n\tp.name &#x3D; name\n&#125;\n\nfunc main() &#123;\n\n\tp :&#x3D;person&#123;&quot;hu&quot;,8&#125;\n\tp.setName(&quot;huyu&quot;)\n\tfmt.Println(p.name)\n&#125;\n&#x2F;&#x2F;值接收者\ntype person struct &#123;\n\t name string\n\t age int8\n&#125;\n\nfunc (p person) setName(name string) &#123;\n\tp.name &#x3D; name\n&#125;\n\nfunc main() &#123;\n\n\tp :&#x3D;person&#123;&quot;hu&quot;,8&#125;\n\tp.setName(&quot;huyu&quot;)\n\tfmt.Println(p.name)\n&#125;\n\n\n\n\n错误处理（暂时大概了解了下）\n概述：\ngo中的错误处理就是类似于java中的异常机制，主要是来处理编译时异常的。\n\n\n背景：\nGo语言没有类似 Java 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。  Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。\n\n\n\n\n宕机（panic）和宕机恢复（recover）\n函数传参问题\n可变参数\n\n类比java，就是向函数中传递的参数个数不确定的时候，可以用可变参数进行传参\n\nfunc myfunc(args ...int) &#123;\n    for _, arg :&#x3D; range args &#123;\n        fmt.Println(arg)\n    &#125;\n&#125;\n\n\n如果不进传递参数的数量不确定，并且类型不确定，可以使用interface类型\n\npackage main\nimport &quot;fmt&quot;\nfunc MyPrintf(args ...interface&#123;&#125;) &#123;\n    for _, arg :&#x3D; range args &#123;\n        switch arg.(type) &#123;\n            case int:\n                fmt.Println(arg, &quot;is an int value.&quot;)\n            case string:\n                fmt.Println(arg, &quot;is a string value.&quot;)\n            case int64:\n                fmt.Println(arg, &quot;is an int64 value.&quot;)\n            default:\n                fmt.Println(arg, &quot;is an unknown type.&quot;)\n        &#125;\n    &#125;\n&#125;\nfunc main() &#123;\n    var v1 int &#x3D; 1\n    var v2 int64 &#x3D; 234\n    var v3 string &#x3D; &quot;hello&quot;\n    var v4 float32 &#x3D; 1.234\n    MyPrintf(v1, v2, v3, v4)\n&#125;\n\n首先说结论：\n\n在Go语言里，go 语言中所有东西都是以值进行传递的，没有引用传递 \n非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；\n有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。\n\n\n非引用类型（值类型）：int，float，bool，string，以及数组和struct\n特点：变量直接存储值，内存通常在栈中分配，栈在函数调用完会被释放\n\n\n引用类型：指针，slice，map，chan，接口，函数等\n特点：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，通过GC回收\n\n\n\n其中 指针可以作为中间的桥梁，获得非引用类型数据的地址，从未能够修改原地址，在结构体类型中常用\n\n\n\n注意事项\n\n编译器在编译时不会管if、else if等语句内的return语句，不知道你具体会在哪里返回，这个只有程序运行时才能确定。所以，如果你程序最后没有return语句，编译器就认为你错了，语法不通过。 \n\n函数可以返回多个值\nfunc swap(x, y string) (string, string) &#123;\n   return y, x\n&#125;\n\n函数可以作为返回值（本质上函数也可以作为变量，叫函数变量）\nfunc test(x int)func() &#123;        &#x2F;&#x2F; 返回函数类型 \n   return func() &#123;          &#x2F;&#x2F; 匿名函数 \n       println(x)            &#x2F;&#x2F; 闭包 \n    &#125; \n&#125; \nfunc main() &#123; \n   x:&#x3D;100\n  \n   f:&#x3D;test(x) \n   f() \n&#125;\n\n\n\n面对对象结构体\n是什么\n\n结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 （就是类似于java中的一个类）\n\n\n如何使用\npackage main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n   var Book1 Books        &#x2F;* 声明 Book1 为 Books 类型 *&#x2F;\n   var Book2 Books        &#x2F;* 声明 Book2 为 Books 类型 *&#x2F;\n\n   &#x2F;* book 1 描述 *&#x2F;\n   Book1.title &#x3D; &quot;Go 语言&quot;\n   Book1.author &#x3D; &quot;www.runoob.com&quot;\n   Book1.subject &#x3D; &quot;Go 语言教程&quot;\n   Book1.book_id &#x3D; 6495407\n\n   &#x2F;* book 2 描述 *&#x2F;\n   Book2.title &#x3D; &quot;Python 教程&quot;\n   Book2.author &#x3D; &quot;www.runoob.com&quot;\n   Book2.subject &#x3D; &quot;Python 语言教程&quot;\n   Book2.book_id &#x3D; 6495700\n\n   &#x2F;* 打印 Book1 信息 *&#x2F;\n   printBook(Book1)\n\n   &#x2F;* 打印 Book2 信息 *&#x2F;\n   printBook(Book2)\n&#125;\n\nfunc printBook( book Books ) &#123;\n   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)\n   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)\n   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)\n   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)\n&#125;\n\n结构体指针\n\n结构体指针可以隐形的使用\n\n&#x2F;&#x2F;如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。\nfunc main() &#123;\n\tv :&#x3D; Vertex&#123;1, 2&#125;\n\tp :&#x3D; &amp;v\n\tp.X &#x3D; 1e9\n\tfmt.Println(v)\n&#125;\n\n方法\n具体使用可以看函数中的方法使用\n理解：\n类比java中的方法，因为java类中可以主动定义方法，但是go只有结构体，所以结构体只能定义类似于java类中的属性，要想定义方法，只能利用类似于“外部挂载的方式”，声明一个函数属于哪个结构体的方式实现java中类的方法实现\n\n\n\n接口\n是什么\n类比java，一个接口是一组方法集合\n如果一个类型包含了一个接口声明的所有方法，那么这个类型就隐式地实现了这个接口。 \n如何理解为隐式实现\n只要实现接口内的全部方法即可，而和接口名称没有任何关系，是基于方法的实现，和传统的OOP接口实现不同，耦合性很小\n\n\n\n\n\n\n理解\ngolang中的接口是golang实现多态的方式，而java是基于继承的方式，我们可以类比java，golang中的接口就是java中的父类，而实现接口的结构体相当于子类，最终的结果就是父类中的引用指向子类的对象（接口的引用指向实现接口的结构体）\n无论是java中的继承还是golang中的接口，多态的实现的本质都是方法的重写\n\n\n应用场景\n类似于usb的例子，电脑有usb接口，如果其他外设想要连接电脑，只要实现usb即可\n在开发中，可以利用接口定义好方法，然后分层来实现，用于开发流程\n\n\n注意事项\n接口本身不可以实例化，但是可以指向实现了接口的结构体变量\n不仅仅是结构体可以实现接口，任何自定义变量都可以实现接口\n接口之间也可以使用继承来增加复用性\n\n\n\n三大特性\n封装\n\n没有java那么明显，仅仅是首字母大小写来规定包内和包外的限制\n\n\n继承\n\n本质上就是代码复用，而golang是通过匿名结构体嵌套实现\n\n\n多态（向上转型）\n\n具有多种状态\n\n思想和java差不多，基本都是啥接口变量可以指向实现响应接口的结构体\n\n\n类型断言（向下转型）\n\n背景：\n\n利用多态调用方法时，只能调用接口声明的方法，但是要想执行具体结构体特殊的方法（实际上就是java中的向下转型，将父类转为子类，从而可以使用子类的特殊方法）就得用到类型断言\na是接口变量\nb是结构体变量\nb &#x3D; a.（结构体类型）\n\n\n转换错误处理\n\n因为接口变量转型得是原来的数据类型，所以为了防止panic，使用标志位进行接收判断\na, flag &#x3D; b.(int8)\nif(flag &#x3D;&#x3D; true)&#123;    &#x2F;&#x2F;转换成功\n    \n&#125;else&#123;              &#x2F;&#x2F;转换失败\n    \n&#125;\n\n\n\n\n\n\n\n","slug":"golang","date":"2022-04-26T05:48:25.000Z","categories_index":"Golang","tags_index":"","author_index":"Hubert"},{"id":"8b277fff122412f48b0619581df54238","title":"K8s","content":"K8s概述前置知识\n容器的本质是一种特殊的进程 \n容器的隔离和资源限制实现\nnamespace\n相当于一个障眼法，利用linux的namespace机制实现隔离，而一个个docker实际上是一个个特殊的进程\nNamespace 技术实际上修改了应用进程看待整个计算机“视 图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。但对于宿主机来 说，这些被“隔离”了的进程跟其他进程并没有太大区别。 \nnamespace的实现有很多类，比如PID，mount，network等方式（这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的 改变，一定是伴随着挂载操作（mount）才能生效。 ）\n\n\ncgroups\nLinux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够 使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。 \n在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织 在操作系统的 &#x2F;sys&#x2F;fs&#x2F;cgroup 路径下 \n在 &#x2F;sys&#x2F;fs&#x2F;cgroup目录下又很多资源，比如CPU，内存，如果我们在对应文件里面创建一个进程对应的文件，文件会自动创建一些目录，对响应的目录进行设置即可对资源进行限制，最后在将进程的PID写入task文件即可\n\n\n容器的文件系统通过chroot进行改变挂载根目录实现（还不是特别懂）\n\n\n容器的安全问题\n在生产环境中，没有人敢把运行在物理机上的 Linux 容器直接暴露到公网上。因为本质来讲就是一个进程，公用同一个内核，所以安全性不高。\n\n\n\n是什么\nKubernetes 是一个容器的编排工具 （用来管理和编排容器的）可以理解为云计算的操作系统\n\n浅析K8s\n技术本质：\n容器本身没有价值，有价值的是“容器编排 ，容器本身是一个底层技术，解决了应用打包这个问题，但是技术要落地到应用，要落地到Pass平台，所以如何利用容器进行商业化的应用才是真正的价值。而容器编排技术正是Pass落地的关键。\n\n\n核心特点：\n容器编排技术有很多，比如Docker Swarm 和 Mesos ，他们都能达到容器编排的目的，但是他们编排技术的出发点不同， Swarm是以docker为核心进行开发，而K8s是借鉴了谷歌的Brog项目，从顶层开始设计，docker仅仅是设计中的一部分，，Kubernetes 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各 种关系，并且为将来支持更多种类的关系留有余地。 而不仅仅是围绕着docker进行发展。\n\n\n价值：\nKubernetes 项目为用户提供的不仅限于一个工具。它真正的价值，乃在于提供 了一套基于容器构建分布式系统的基础依赖。\n\n\n\n核心组件\nmaster：主控节点 \n\nAPI Server：集群统一入口，以restful风格进行操作，同时交给etcd存储 \nscheduler：节点的调度，选择node节点应用部署\ncontroller-manager：处理集群中常规后台任务，一个资源对应一个控制器\netcd：存储系统，用于保存集群中的相关数据\n\n\nWork node：工作节点 \n\nKubelet：master派到node节点代表，管理本机容器 \n一个集群中每个节点上运行的代理，它保证容器都运行在Pod中\n负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理\n\n\nkube-proxy：提供网络代理，负载均衡等操作\n\n\n\n核心概念\nPod\nVolume\nController\nDeployment\nService\nLabel\nNamespace\nAPI\n\n搭建集群搭建方式\n单master集群\n多master集群\n\n部署方式\nKubeadm\n\n\n\n\n\n\n\n\n\n\nkubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署： \n创建一个Master 节点kubeadm init\n将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;\n\n\n原理：\n把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n\n\n\n\n二进制搭建\n\n\n\n\n\n\n\n\n\n\n从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。\nKubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。\n\n\n\n\n相关工具kubectl\n\nkubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署\n\nYAMl\n\nYAML文件：就是资源清单文件，用于资源编排 \nk8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。\n\n相关操作\n编写YAML文件\n\nYAML文件本质上是一个配置文件，用来把容器的定义、参数、配置，统统记录在一个 YAML 文件中 ，对于K8s而言，YAML是API Object \n\n具体格式：\n\n主要分为四大部分\n\napiVersion   api版本\nkind              API对象种类\nmetadata    对象标识数据\nspec              对象功能描述\n\n\n&#96;&#96;&#96;yamlapiVersion: apps&#x2F;v1kind: Deploymentmetadata:  name: nginx-deploymentspec:  selector:matchLabels:  app: nginx  replicas: 2  template:metadata:  labels:    app: nginx  spec:containers:  - name: nginx  image: nginx:1.7.9  ports:    - containerPort: 80\n\n- 相关命令\n\n  - &#96;&#96;&#96;java\n    $ kubectl create -f nginx-deployment.yaml       &#x2F;&#x2F;运行YAML文件\n\n\n&#96;&#96;&#96;java$ kubectl get pods -l app&#x3D;nginx &#x2F;&#x2F;查看运行的pod\n\n- &#96;&#96;&#96;java\n  kubectl describe pod nginx-deployment-67594d6bf6-9gdvr &#x2F;&#x2F;查看对象的详细信息\n  &#x2F;&#x2F;其中的events记录了操作pod的重要事件，经常用于debug\n\n\n\n核心概念Pod\n是什么\n\n是k8s的最小的单位级，里面通过有单个或者多个容器构成，Pod是它们的逻辑主机，Pod包含业务相关的多个应用容器。\n\n\n实现原理\n\npod本质上是一个逻辑上的集合体，并不是具体使用相关隔离和限制技术创建的一个空间\n\n实现逻辑体的原理：\n\n共享网络命名空间（networkname space）\n在pod中，不同的容器间属于对等关系，而不是从属关系，所以所有的容器只要共享Infra容器的网络命名空间即可\n其中Infra容器是永远处于暂停状态的特殊容器，和pod声明周期进行了绑定\n\n\n共享存储卷\n在创建pod的时候声明volume即可\n\n\n\n\n\n\n为什么是pod而不是容器\n\npod的存在主要是让几个紧密连接的几个容器之间共享资源 （进程间存在亲密性）如果以容器为单位则管理开销很大\n容器的设计模式（pod设计的核心思想！！！）\n理解：相当于设计一个组合拳，用来解决单个容器难以解决的问题 \nsidecar模式：sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进 程（主容器）之外的工作。\n\n\n\n\npod设计的核心思想：\n\npod的本质设计是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用 户程序。 \n是一种传统应用架构到微服务架构的一种过渡\n应用从物理机到虚拟机，因为只是底层资源发生了池化，所以迁移的架构变化不大，但是在云原生时代，不能把容器看成一个更加轻量化的虚拟机，因为容器的本质就是一个进程，而虚拟机理往往包含了多个进程，所以此阶段应用的上云不能只是套模板，而是根据容器的特点进行设计，而不仅仅是将虚拟机装进容器。而pod可以理解为云原生的虚拟机\n\n\n\n\npod相关属性\n\napiserver：\n\nkind\n\nmetadata\n\nspec：\n\nNodeSelector：是一个供用户将 Pod 与 Node 进行绑定的字段 \nNodeName：一旦 Pod 的这个字段被赋值，Kubernetes 项目就会被认为这个 Pod 已经经过了调 度，调度的结果就是赋值的节点名字。 \nHostAliases：定义了 Pod 的 hosts 文件（比如 &#x2F;etc&#x2F;hosts）里的内容 \nshareProcessNamespace&#x3D;true： 容器之间共享相关命名空间\nhostNetwork: true    hostIPC: true    hostPID: true    容器共享宿主机的 Namespace \nInit Container ：\nContainer ：\nname：\nimage\nport\nImagePullPolicy ：它定义了镜像拉取的策略\n\n- IfNotPresent：默认值，镜像在宿主机上不存在才拉取\n- Always：每次创建Pod都会重新拉取一次镜像\n- Never：Pod永远不会主动拉取这个镜像\n\n\nlifecycle: \npostStart:  在容器启动后，立刻执行一个指定的操作 （不保证严格顺序）\npreStop:  容器被杀死之前 ，立刻执行一个指定的操作 （preStop 操作的执行，是同步的）\n\n\n\n\nstatus：（pod的状态，声明周期）\n\nphase ：（pod的当前状态）\nPending：这个状态意味着，Pod 的 YAML 文件已经提交给了 Kubernetes，API 对象已经被 创建并保存在 Etcd 当中。但是，这个 Pod 里有些容器因为某种原因而不能被顺利创建。比 如，调度不成功。 \nRunning。这个状态下，Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创 建成功，并且至少有一个正在运行中。 \nSucceeded。这个状态意味着，Pod 里的所有容器都正常运行完毕，并且已经退出了。这种情 况在运行一次性任务时最为常见。 \nFailed。这个状态下，Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状 态的出现，意味着你得想办法 Debug 这个容器的应用，比如查看 Pod 的 Events 和日志。 \nUnknown。这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kube\u0002apiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题。\n\n\nConditions ：（描述造成当前 Status 的具体原因）\nPodScheduled\nReady \nInitialized\nUnschedulable。\n\n\n\n\n\n\nPodpreset\n\n是什么？\n就是事先定义好的pod，用来追加新建pod的内容，\n\n\n目的：\n减少新建pod的复杂度，批量化修改pod\n\n\n注意：\n它只能修改新建的pod的内容，而对控制器内容无法改变\n当有多个podpreset时，新建的pod会将他们的字段进行融合使用\n\n\n\n\nPod资源调度限制\n\nrequest：表示调度所需的资源\nlimits：表示最大所占用的资源\n只有满足request的要求才能被调用\n\n\n\n\nPod的重启策略（恢复机制）\n\nAlways：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】\nOnFailure：当容器异常退出（退出状态码非0）时，才重启容器。\nNever：当容器终止退出，从不重启容器 【批量任务】\n\n\nPod的健康检查\n\n通过探针技术\n探针种类\nlivenessProbe\n指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略决定未来。如果容器不提供存活探针， 则默认状态为 Success。\nreadinessProbe\n指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 Failure。 如果容器不提供就绪态探针，则默认状态为 Success。\n\n\nstartupProbe\n指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其 重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 Success。\n\n\n\n\n检测结果\nSuccess（成功）\n容器通过了诊断。\n\n\nFailure（失败）\n容器未通过诊断。\n\n\nUnknown（未知）\n诊断失败，因此不会采取任何行动。\n\n\n\n\n探针的检查机制\nexec\n在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。\n\n\ngrpc\n使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 “SERVING”，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 “GRPCContainerProbe” 特性门控时才能使用。\n\n\nhttpGet\n对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。\n\n\ntcpSocket\n对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。\n\n\n\n\n\n\n\n\nPod的资源调度策略\n\n根据资源的调度限制request进行调配\n\n根据nodeSelector标签进行调度\n\n根据点亲和性 nodeAffinity \n\n硬亲和性：约束条件必须满足\n软亲和性：尝试满足，不保证\n\n\n\n\n污点和污点容忍\n\n概述：\n在调度pod的时候，有request，nodeSelector和nodeAffinity对nod的策略调度，但是pod最终归属是在某个node节点上，所以也可以通过对node的属性进行相关设置，从而侧面实现pod的调度\n\nTaint 污点：节点不做普通分配调度，是节点属性\n\n\n使用场景\n\n最大的应用就是master节点，因为里面不能有pod\n专用节点【限制ip】\n配置特定硬件的节点【固态硬盘】\n基于Taint驱逐【在node1不放，在node2放】\n\n\n相关操作\n\n查看污点情况\nkubectl describe node k8smaster | grep Taint\n\n\nNoSchedule：一定不被调度\nPreferNoSchedule：尽量不被调度【也有被调度的几率】\nNoExecute：不会调度，并且还会驱逐Node已有Pod\n\n\n如何对node添加污点\nkubectl taint node [node] key&#x3D;value:污点的三个值\n\n删除污点\n\n\nkubectl taint node k8snode1 env_role:NoSchedule-\n\n\n\nController\n是什么\nController是在集群上管理和运行pod的对象 \n\nPod和Controller的关系\n\ncontroller就是pod的控制器，用来控制pod的相关功能，比如回滚，    弹性伸缩等等\nPod 和 Controller之间是通过label标签来建立关系，同时Controller又被称为控制器工作负载\n\n\n种类\n\ndeployment\n\nStatefulset\n\nDaemonSet\n\nJob\n\nCronJob\n\nReplication Controller\n\nReplica Set\n\n\n\nDeployment\n\n概述\n\n是controller的一种\n\n\n作用：\n\npod的水平扩展&#x2F;收缩和滚动更新\n\nDeployment控制器可以部署无状态应用\n\n\n\n原理：\n\nDeployment控制着RS的版本，而RS控制着Pod副本的数量\n水平扩展&#x2F;收缩：RS控制\n滚动更新：两个RS交替更替\n\n\n\n\nStatefulset\n\n主要用于部署有状态的pod\n适合StatefulSet的业务包括数据库服务MySQL 和 PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务\n\n\nDaemonSet\n\nDaemonSet 即后台支撑型服务，主要是用来部署守护进程 \n典型的后台支撑型服务包括：存储、日志和监控等。在每个节点上支撑K8S集群运行的服务。\n\n\nJob\n\nJob也即一次性任务 \nJob管理的Pod根据用户的设置把任务成功完成就自动退出了。\n\n\nCronJob\n\n定时任务\n\n\nReplication Controller\n\nRC是K8S中较早期的技术概念，只适用于长期伺服型的业务类型，比如控制Pod提供高可用的Web服务。\n\n\nReplica Set\n\nReplica Set 检查 RS，也就是副本集。RS是新一代的RC，提供同样高可用能力，区别主要在于RS后来居上，能够支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数来使用\n\n\n\nService\n是什么\n是一个为客户端访问pod的一个对象\n\n作用\n\n要稳定地提供服务需要服务发现和负载均衡能力 \n\n服务发现\n\n因为Pod每次创建都对应一个IP地址，而这个IP地址是短暂的，每次随着Pod的更新都会变化，假设当我们的前端页面有多个Pod时候，同时后端也多个Pod，这个时候，他们之间的相互访问，就需要通过注册中心，拿到Pod的IP地址，然后去访问对应的Pod\n\n\n负载均衡\n\n页面前端的Pod访问到后端的Pod，中间会通过Service一层，而Service在这里还能做负载均衡，负载均衡的策略有很多种实现策略，例如：\n随机\n轮询\n响应比\n\n\n\n\n\n\nService常用类型有三种\n\nClusterIp：集群内部访问\nNodePort：对外访问应用使用\nLoadBalancer：对外访问应用使用，公有云\n\n\n\n声明式API\n个人理解：\n\n声明式API是K8s的核心，因为互联网的规模很大，仅仅使用K8s内部的编排对象可能不够用，所以要自己编写API对象和编排对象进行适合业务的资源控制，而这种功能的实现依靠的是K8s的API插拔机制，可以理解为在不修改K8s的基础上进行功能的扩展，所以我们编写API对象和编排对象都是通过声明式API进行编写，而通过API插拔机制进行实现，而这也是k8s使用者到k8s玩家的一个重要过渡\n\n\n请求\n\n响应式\n声明式\n\n\n是什么？\n\n是 kubectl apply 命令。 YAML只是个配置文件\nkubectl apply，执行了一个对原有 API 对象的 PATCH 操 作。 \n请求分类：\n响应命令式请求 ：一次只能处理一个写请求，否则会有产生冲突的可能 （kubectl replace ）\n声明式请求 ：一次能处理多个写操作，并且具备 Merge 能力。 （kubectl apply）\n\n\n\n\n声明式 API 的设计 \n\nAPI 对象在 Etcd 里的完整资源路径 \nGroup（API 组） \nVersion（API 版本） \nResource（API 资源类型）\n\n\n\n\n声明式 API 的创建流程\n\n创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给 了 APIServer。 \n过滤这个请求，并完成一些前置性的工作，比如授权、超时 处理、审计等。 \n进入 MUX 和 Routes 流程 \nMUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所 \nHandler就是完成对象的绑定\nKubernetes 对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项 目里找到 CronJob 对象的定义 \nKubernetes 会匹配 API 对象的组 \nKubernetes 会进一步匹配到 API 对象的版本号 \nKubernetes 会匹配 API 对象的资源类型\n\n\n\n\n\n\n\n\n根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。 \n进行一个 Convert 工作 \n把用户提交的 YAML 文件，转换 成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提 交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。\n\n\nAPIServer 会先后进行 Admission() 和 Validation() 操作 \nAdmission()\nValidation()  \nValidation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保 存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能 在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。\n\n\n\n\n\n\nAPIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调 用 Etcd 的 API 把它保存起来。\n\n\nAPI 插件机制：CRD \n\n是什么？\n\n自定义 API 资源 \nCRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型\n\n\n个人理解：\n\n尽管K8s自带的一些资源定义已经够用，但是在具体的使用上，需要量身定制一些“自定义资源”，也就是CR（用户自定义资源），而CR的定义就是我们要的的CRD\n\n\n如何编写：\n\n创建API对象：\n\n\n\n进行定义：\n\n\n在K8s进行宏观的定义\n\n编写YAML文件\n\napiVersion: apiextensions.k8s.io&#x2F;v1beta1\nkind: CustomResourceDefinition\nmetadata:\n name: networks.samplecrd.k8s.io\nspec:\n group: samplecrd.k8s.io\n version: v1\n names:\n kind: Network\n plural: networks\n scope: Namespaced\n\n\n用Go语言进行微观的定义\n\n用GO创建相关文件夹\npkg&#x2F;apis&#x2F;samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的 全局变量 \npkg&#x2F;apis&#x2F;samplecrd 目录下添加一个 doc.go 文件 ，起到的是全局的代码生成控制的作用，所以也被称 为 Global Tags。 \npkg&#x2F;apis&#x2F;samplecrd 目录下添加一个 添加 types.go 文件。顾名思义，它的作用就是定义一个 Network 类型到底有 哪些字段（比如，spec 字段里的内容） \n除了定义 Network 类型，你还需要定义一个 NetworkList 类型\n\n\n编写的一个 pkg&#x2F;apis&#x2F;samplecrd&#x2F;v1&#x2F;register.go 文件 \nregistry 的作用就是注册一个类型 （Type）到 APIServer 中。而这个内层目录下的 register.go，就是这个注册流程要使用的代 码。\n\n\n\n\n\n\n\n\n\n\n使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动 生成 clientset、informer 和 lister\n\n\n\n\n\n\n\n为这个 API 对象编写一个自定义控制器（Custom Controller）    这一部分要结合具体的场景进行深刻的认识\n\n编写 main 函数 \nmain 函数的主要工作就是，定义并初始化一个自定义控制器（Custom Controller），然后启 动它。 \n第一步：main 函数根据我提供的 Master 配置（APIServer 的地址端口和 kubeconfig 的路 径），创建一个 Kubernetes 的 client（kubeClient）和 Network 对象的 client（networkClient）。 \n第二步：main 函数为 Network 对象创建一个叫作 InformerFactory（即： networkInformerFactory）的工厂，并使用它生成一个 Network 对象的 Informer，传递给控 制器。 \n第三步：main 函数启动上述的 Informer，然后执行 controller.Run，启动自定义控制器。\n\n\n编写自定义控制器的定义 \n及编写控制器里的业务逻辑\n\n\n\n\n\n\nIstio 项目\n\n是什么\n\n一个基于 Kubernetes 项目的微服务治理框架\n\n\n核心\n\nEnvoy 容器 （使用的sidecar模式）\n作用：Envoy 容器就 能够通过配置 Pod 里的 iptables 规则，把整个 Pod 的进出流量接管下来。 \n原理：\n就是在用户创建pod的时候自动添加相关envoy的信息，进而创建envoy\n实现原理：\n首先Istio 会将这个 Envoy 容器本身的定义，以 ConfigMap 的方式保存在 Kubernetes 当 中。\n然后通过 Initializer将Envoy的信息加入到pod的API当中\n该步骤的实现原理：\nIstio 将一个编写好的 Initializer，作为一个 Pod 部署在 Kubernetes 中。而这个pod的基础镜像是个自定义的控制器，控制器的作用就是为新建的pod打上标签，而这个标签就是在ConfigMap保存的内容\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原理：\n\n运行原理：\n\nIstio 的控制层（Control Plane）里的 Pilot 组件，就能够通过调用每个 Envoy 容器的 API，对这个 Envoy 代理进行配置，从而实现微服务治理。\n\n\nDynamic Admission Control。 （动态准入控制）\n\n背景：\nk8s在请求apiserver后会进行初始化，“初始化”操作的实现，借助的是一个叫作 Admission 的功能 （就是一段功能性代码选择性地被编译进 APIServer 中，在 API 对象创建之后会被立刻调用到。）但是如果要更改Admission的配置要重新编译apiserver，开销很大，所以，Kubernetes 项目为我们额外提供了一种“热插拔”式的 Admission 机制，它就是 Dynamic Admission Control，也叫作：Initializer。 \n\n是什么\n\n也叫Initializer ，是热插拔的Admission\n\n\n依赖：\n\n在 Initializer 更新用户的 Pod 对象的时候，必须使用 PATCH API 来完成\n\n\n\n\n\n\n\n\n\n","slug":"K8s","date":"2021-08-26T10:49:36.000Z","categories_index":"K8s","tags_index":"","author_index":"Hubert"},{"id":"0df63ec25452415f0b2c8961aba42a85","title":"Net-OSPF之负载均衡","content":"这篇内容主要为了解，具体的功能技术实现自己并未动手操作，但是这篇内容最大的启示是ospf的功能不仅仅是AS内的发现和计算路由，还有其他功能，我们学习一种技术时不能局限于技术本身，而是要善用技术，这样才能真正理解相关技术，从而做到融会贯通\n概述：\n关于ospf：\n\n​      OSPF(Open Shortest Path First开放式最短路径优先 )是一个内部网关协议，用于在单一自治系统(AS)内决策路由。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。 OSPF路由协议用于在单一自治系统内决策路由。 OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。 OSPF路由协议是一种典型的链路状态路由协议，一般用于同一个路由域内。在这里，路由域是是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个 AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。\n\n\n关于负载均衡\n\n个人理解的负载均衡是一种 “压力分担”，是一种横向的扩展，而自己了解的负载均衡技术分类可以分为两种\n平台分类\n硬件\n思科的一些设备（IP+端口）\n\n\n软件\nHTTP重定向\nDNS重定向\n反向代理\n\n\n\n\n网络层分类\n四层： \nIP+端口\n\n\n七层：\n基于一些软件，比如nginx等等\n\n\n\n\n\n\n结合：\n负载均衡可以从多方面实现，而ospf作为AS内一个重要的路由协议，基本承载了三层的流量，所以在OSPF上也可以设计负载均衡\n\n\n核心思想\nospf的最大的特点是基于链路状态，而链路状态实际上是一种网路开销的体现，而OSPF会根据链路状态计算路由，到达目标相同Cost值的路径，可以执行负载均衡 \n简单的说就是到达一个目的地有很多条路，每条路的开销相同，因此流量也可以进行相应的负载均衡\n\n\nOSPF的负载均衡只是一方面，通常要和其他技术搭配使用\n\n使用场景\nOSPF负载均衡一般与其他负载均衡一起搭建成负载均衡集群，提供高可用、高负载服务。 \nOSPF+LVS-DR集群\n\n","slug":"net4","date":"2021-08-02T05:48:25.000Z","categories_index":"Net","tags_index":"","author_index":"Hubert"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"Docker概述\n是什么\n是一款容器引擎，是一个用于开发，交付和运行应用程序的开放平台 \n\n作用\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 \n（应用和相关依赖环境一起打包到容器当中）解决环境依赖，提高开发效率\n\n三要素\n\n镜像（花卷）\n\n\n\n\n\n\n\n\n\n\n是什么？\n\n是一个软件包，该包打包好运行环境，是创造容器的一个模板。是rootfs\n\n\n特性：\n\n强一致性\n因为镜像包含了rootfs，而rootfs是包含了操作系统的文件和目录，所以docker容器从底层文件解决了环境的依赖，从而达到一次构建，到处运行的目的\n\n\n\n\n特点\n\n镜像层只能可读\n\n\n原理\n\nUnionFS（联合文件系统），Docker的镜像底层基础是联合文件系统，改系统的特点是支持多层的叠加文件系统，就像花卷一样，Docker可以利用该特点（分层技术）来进行创建特定的镜像\n\n\n镜像采用分层技术的优点\n\n镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。 \n功能可扩展性\n\n\n镜像和容器的关系\n\n类比java，镜像是类，容器是实例\n镜像只能可读，但是容器可操作，而镜像到容器的这个“实例化”的过程是在镜像层上添加容器层\n\n\n虚悬镜像（dangling images）\n\n就是仓库名和tag标签为空的镜像\n\n相关操作\n\n查看虚悬镜像\ndocker image ls -f dangling&#x3D;true\n\n删除虚悬镜像\ndocker image prune\n\n\n\n\n\n\n\n容器\n\n本质是一个进程\n\n\n仓库\n\n存放镜像的地方\n\n\n\n+-----+-----+-----+-----+                                   +-----+-----+-----+-----+\n|App A|App B|App C|App D|     +-----+-----+-----+-----+     |App A|App B|App C|App D|\n+-----+-----+-----+-----+     |App A|App B|App C|App D|     +-----+-----+-----+-----+\n|+---------------------+|     +-----+-----+-----+-----+     |Guest|Guest|Guest|Guest|\n||   Runtime Library   ||     |Lib A|Lib B|Lib C|Lib D|     | OS0 | OS1 | OS2 | OS3 |\n|+---------------------+|     +-----+-----+-----+-----+     +-----+-----+-----+-----+\n||       Kernel        ||     |    Container Engine   |     |        Hypervisor     |\n|+---------------------+|     +-----------------------+     +-----------------------+\n|   Operating System    |     |         Host OS       |     |         Host OS       |\n+-----------------------+     +-----------------------+     +-----------------------+\n|       Hardware        |     |        Hardware       |     |        Hardware       |\n+-----------------------+     +-----------------------+     +-----------------------+\n    Physical Machine                  Container                 Type II Hypervisor\n\n数据卷\n\n是什么？\n\n是一个存储文件，存储docker容器产生的数据\nDocker将运用与运行的环境打包形成容器运行， Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来， 那么当容器删除后，数据自然也就没有了。 为了能保存数据在Docker中我们使用卷。\n\n\n作用\n\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n\n\n特点\n\n数据卷可在容器之间共享或重用数据\n卷中的更改可以直接生效\n数据卷中的更改不会包含在镜像的更新中\n数据卷的生命周期一直持续到没有容器使用它为止\n\n\n\n\n\n浅析原理\n容器的本质是一种特殊的进程 \n容器本身没有价值，有价值的是“容器编排 ，容器本身是一个底层技术，解决了应用打包这个问题，但是技术要落地到应用，要落地到Pass平台，所以如何利用容器进行商业化的应用才是真正的价值。\n容器的隔离和资源限制实现\nnamespace\n理解：\n相当于一个障眼法，利用linux的namespace机制实现隔离，而一个个docker实际上是一个个特殊的进程\nNamespace 技术实际上修改了应用进程看待整个计算机“视 图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。但对于宿主机来 说，这些被“隔离”了的进程跟其他进程并没有太大区别。\n\n\n分类\nnamespace的实现有很多类，比如PID，mount，network等方式（但是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的 改变，一定是伴随着挂载操作（mount）才能生效。 ）\n\n\nnamespace的位置\n尽管改变了进程的视图，但是在OS上确是实际存在，在namespace就映射在 &#x2F;proc&#x2F;PID&#x2F;ns中，在该文件夹中存储了容器namespace所有的映射，而这也是docker excec能进入一个容器的原因（本质上是一个进程加入另一个进程，而进入docker这进程实际上是加入docker的namespace）\n\n\n\n\ncgroups\n概念\nLinux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够 使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。\n\n\n实现资源限制原理：\n在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织 在操作系统的 &#x2F;sys&#x2F;fs&#x2F;cgroup 路径下 \n在 &#x2F;sys&#x2F;fs&#x2F;cgroup目录下又很多资源，比如CPU，内存，如果我们在对应文件里面创建一个进程对应的文件，文件会自动创建一些目录，对响应的目录进行设置即可对资源进行限制，最后在将进程的PID写入task文件即可\n\n\n\n\n\n\n容器的安全问题\n在生产环境中，没有人敢把运行在物理机上的 Linux 容器直接暴露到公网上。因为本质来讲就是一个进程，公用同一个内核，所以安全性不高。\n\n\n\n操作容器操作\ndocker run   创建并运行容器\n\n\n\n\n\n\n\n\n\n$ docker run -it ubuntu &#x2F;bin&#x2F;bash\n-i: 交互式操作。\n-t: 终端。\nubuntu: ubuntu 镜像。\n&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。\n\n\n$ docker run -itd --name ubuntu-test ubuntu &#x2F;bin&#x2F;bash\n在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。\n\n\n\n--name  创建名称\n-d 后台运行\n-P 自动端口映射\n-p 指定端口映射 （默认为tcp）                -p 127.0.0.1：5000:5000\nrunoob@runoob:~$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py  （绑定UDP）\n\ndocker stop   停止容器\n\n\n\n\n\n\n\n\n\n$ docker stop &lt;容器 ID&gt;\n\ndocker start   运行容器\n\n\n\n\n\n\n\n\n\n$ docker start  &lt;容器 ID&gt;\n\ndocker ps       查看当前容器\n\ndocker exec  进入当前容器\n\n\n\n\n\n\n\n\n\ndocker exec -it &lt;容器 ID&gt;  &#x2F;bin&#x2F;bash\n\n相关信息总结\nCONTAINER ID: 容器 ID。\nIMAGE: 使用的镜像。\nCOMMAND: 启动容器时运行的命令。\nCREATED: 容器的创建时间。\nSTATUS: 容器状态。\n状态有7种：\ncreated（已创建）\nrestarting（重启中）\nrunning 或 Up（运行中）\nremoving（迁移中）\npaused（暂停）\nexited（停止）\ndead（死亡）\n\n\n\n\nPORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。\nNAMES: 自动分配的容器名称。\n\n\n\n\ndocker export    导出容器\n$ docker export 1e560fca3906 &gt; ubuntu.tar\n\ndocker import  导入容器\n$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1\n\ndockert rm   删除容器\n$ docker rm -f 1e560fca3906\n\n下面的命令可以清理掉所有处于终止状态的容器。\n$ docker container prune\n\ndocker port   查看容器端口映射\n&gt; &gt; &gt; &gt; &gt; &gt; runoob@runoob:~$ docker port bf08b7f2cd89\n&gt; &gt; &gt; &gt; &gt; &gt; 5000&#x2F;tcp -&gt; 0.0.0.0:5000\n\ndocker log  查看容器日志\nrunoob@runoob:~$ docker logs -f bf08b7f2cd89\n\n容器互联\n\n\n\n\n\n\n\n\n\n\n创建互联网络\n$ docker network create -d bridge test-net\n\n将容器添加到互联网络\n$ docker run -itd --name test1 --network test-net ubuntu &#x2F;bin&#x2F;bash\n\n\n\n镜像操作\ndocker images     \n查看本地镜像仓库\n\ndocker commit\n创建某镜像的副本，成为新的容器\n\ndocker pull\n下载镜像\n\ndocker research xxx\n搜索镜像\n\ndocker   rmi \n删除镜像\n\n创建镜像两种方式\n\n通过进入容器进行创建（实际上是创建文件的副本）\nrunoob@runoob:~$ docker commit -m&#x3D;&quot;has update&quot; -a&#x3D;&quot;runoob&quot; e218edb10161 runoob&#x2F;ubuntu:v2\nsha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8\n\n通过DockerFile进行创建\nrunoob@runoob:~$ docker build -t runoob&#x2F;centos:6.7 .\nSending build context to Docker daemon 17.92 kB\nStep 1 : FROM centos:6.7\n ---&gt; d95b5ca17cc3\nStep 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;\n ---&gt; Using cache\n ---&gt; 0c92299c6f03\nStep 3 : RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd\n ---&gt; Using cache\n ---&gt; 0397ce2fbd0a\nStep 4 : RUN useradd runoob\n......\n\n\ndocker tag  \n创建镜像标签\nrunoob@runoob:~$ docker tag 860c279d2fec runoob&#x2F;centos:dev\n\n仓库操作\ndocker login\ndocker logout\ndocker pull \ndocker research\ndocker  push\n\nDockerfile\n是什么？\n\n创建镜像的文本文件，用来指导创建镜像\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n\n\n理解：\n\n创建方式：\n创造镜像有两种方式，第一种是创建容器，在容器里面进行创建，第二种是dockerfile文本文件创建，而dockerfile创建的本质是使用脚本自动化的实现第一种模式。\n\n\n为什么要创建镜像？\n不同生产环境下具有不同的底层软件支持，所以要创建一个合适的镜像，而不是仅仅使用通用的，说白了就是搭建合适的具有相关功能的镜像\n\n\n\n\n创建流程\n\ndocker从基础镜像运行一个容器\n\n执行一条指令并对容器作出修改\n\n执行类似docker commit的操作提交一个新的镜像层\n\ndocker再基于刚提交的镜像运行一个新容器\n\n执行dockerfile中的下一条指令直到所有指令都执行完成\n就像做花卷一样，一层一层的叠上去\n\n\n\n关键字\n\nFROM                     基于那个基础镜像\nMAINTAINER        相关维护者的信息\nRUN                        执行的相关命令————-》等同于在终端执行的shell命令            （在docker build的时候执行）\nEXPOSE                  对外的是什么接口\nWORDIR                 终端默认登录的工作目录\nUSER                       指定该镜像以什么样的用户去执行，如果都不指定，默认是root\nENV                           指定环境变量（WORKDIR $MY_PATH ）\nADD                           将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\nCOPY                       将宿主机目录下的文件拷贝进镜像\nVOLUME                    容器数据卷，用于数据保存和持久化工作\nCMD               Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换    （在docker run的时候执行）\nENTRYPOINT    类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的CMD命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序（未指定时为隐式声明）\nENTRYPOINT 和  CMD配合使用，此时的CMD的任务不是执行命令，而是传递参数，并且cmd的参数会受docker run后面的参数影响\n\n\n\n\n创建步骤\n\n编写Dockerfile文件（D一定要大写，注意保留字的使用）\n\ndocker build -t  新镜像名称：TAG .  （注意不要忘记后面的那个点）\n\ndocker run -it 新镜像名字:TAG \n\n这三部对应了上面的三张图\n\n\n\n\n\nDocker网络\n是什么\n就是容器之间的网络连接\n\n\n作用\n容器间的互联和通信以及端口映射\n容器IP变动时候可以通过服务名直接网络通信而不受到影响\n\n\n模式\nbridge\n相当于NAT，每个容器通过Docker0这个虚拟的路由器分配得到各自的IP\n\n\nhost\n容器和宿主机公用同一个IP地址\n\n\nnone\n禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环)\n\n\ncontainer\ncontainer⽹络模式 新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 \n就是和一个容器只共享网络\n\n\n\n\n思考\nbridge和host的区别\nhost模式中，因为容器的ip为宿主机Ip，所以在效率上更高，利用率跟高，bridge因为受到统一的安排，所以更好的管理\n\n\n\n\n\n","slug":"docker","date":"2021-05-16T05:48:25.000Z","categories_index":"Docker","tags_index":"","author_index":"Hubert"},{"id":"52bf4c42f2d4889a67cc0b2c3cdd70c7","title":"Java-项目总结","content":"SBMS项目笔记前置知识Servlet\n是什么\n狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类 （一般开发都继承Httpservlet来实现）\n\n\n作用\n主要功能在于交互式地浏览和修改数据 \n理解：\n在MVC三层架构中，servlet处于C（控制层），简单点说就是接受前端来的参数，然后调用M层的逻辑调用，然后返回和转跳响应内容\n\n\n\n\n工作原理：\n用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。\nServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。\n\n\nServlet 接口中定义的方法：\nvoid init(ServletConfig var1) throws ServletException; \nServletConfig getServletConfig();\nvoid service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; \n需要实现的核心业务方法\n\n\nString getServletInfo();\nvoid destroy();\n关于方法捏调用的对象解析：\nServletConfig   传递初始化信息\nServletRequest   将接受到的信息传递进去\nServletResponse  将返回的信息封装\nServletContext \n就是通过该对象可以访问到程序的上下文信息\n\n\n\n\n\n\n声明周期\ninit（）        创建（创建后可重复调用）\n当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。\n\n\nservice（） 调用\ndestroy（） 摧毁\ndestory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。\n\n\n\n\nServlet的使用更迭\nGenericServlet implements Servlet \n1.为Servlet接口中的所有方法提供了默认的实现，则程序员需要什么就直接改什么，不再需要把所有的方法都自己实现了。\n2.提供方法，包围ServletConfig对象中的方法。\n\n\nHttpServlet extends GenericServlet implements Serializable  \nHttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。\n\n\n\nJDBC\n是什么\n\n个人理解为连接的中间层\nJDBC的全称是Java数据库连接(Java Database connect)，它是一套用于执行SQL语句的Java API。\n\n\n作用\n\n应用程序可通过这套API连接到关系数据库，并使用SQL语句来完成对数据库中数据的查询、更新和删除等操作。\n\n\n构成\n\nJDBC驱动管理器：负责注册特定的JDBC驱动器，主要通过java.sql. Driver Manager类实现。 \nJDBC驱动器API：由Sun公司负责制定，其中最主要的接口是java.sql. Driver接口。 \nJDBC驱动器：它是一种数据库驱动，由数据库厂商创建，也称为JDBC驱动程序JDBC驱动器实现了JDBC驱动器API，负责与特定的数据库连接，以及处理通信细节。\n\n\n具体获得连接操作：\npublic class Example01 &#123;\n    public static void main(String[] args) throws SQLException &#123;\n        &#x2F;&#x2F;1.注册数据库的驱动\n        DriverManager.registerDriver(new com.mysql.jdbc.Driver());\n        &#x2F;&#x2F;2.通过 DriverManager获取数据库连接\n        String url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;chapter01&quot;;\n        String usernames&#x3D;&quot;root&quot;;\n        String password&#x3D;&quot;itcast&quot;;\n        Connection conn&#x3D;DriverManager.getConnection(url, username, password);\n        &#x2F;&#x2F;3.通过 Connection对象获取 Statement对象\n        Statement stmt&#x3D; conn.createStatement();\n        &#x2F;&#x2F;4.使用 Statement执行SQL语句\n        String sql&#x3D;&quot;select * from users&quot;;\n        ResultSet rs&#x3D;stmt.executeQuery(sql);\n        &#x2F;&#x2F;5、操作 ResultSet结果集\n        System.out.println(&quot;id|name|password|email|birthday&quot;);\n        while (rs.next()) &#123;\n            int id&#x3D;rs.getInt(&quot;id&quot;);     &#x2F;&#x2F;通过列名获取指定字段的值\n            String name&#x3D;rs.getString(&quot;name&quot;);\n            String psw&#x3D;rs.getString(&quot;password&quot;);\n            String email&#x3D;rs.getString(&quot;email&quot;);\n            Date birthday&#x3D;rs.getDate(&quot;birthday&quot;);\n            System.out.println(id+&quot;|&quot;+name+&quot;|&quot;+psw+&quot;|&quot;+email+&quot;|&quot;+birthday); \n        &#125;\n        &#x2F;&#x2F;6.回收数据库\n        rs.close();\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n项目架构\nMVC三层架构\nM: model层\ndao\n与数据库进行交互，填写相关sql语句\n\n\nservice\n编辑核心业务，然后进行封装，用于contro层的调用\n\n\n\n\nV：view层\n视图层，通过JSP技术，进行前端页面的动态展示\n\n\nC：controller层\n控制层，通过sevlet实现业务的调配工作\n\n\n\n\n\n具体代码似乎在github上面搭建的博客有点bug，链接图片无法显示，所以这部分就只能省略\n总结：\n该项目是第一个实战项目，虽然使用的技术栈很老，但是也清晰的从底层了解了一些web后端的过程，其次从架构上，通过MVC三层架构进行了解，虽然现在都是微服务架构，但是MVC这种单体架构自己可以了解，增强对程序开发流程的认知。这个项目算是自己编程的入门吧。\n\n","slug":"java5","date":"2021-05-11T05:48:25.000Z","categories_index":"Java","tags_index":"","author_index":"Hubert"},{"id":"8abdb583e8b93346cd23da8d5b3ea2a5","title":"CloudComputing-初识","content":"云计算\n是什么\n网络+计算\n\n在服务角度层面：\n像自来水一样提供基础的算力服务，Iass Pass Sass\n\n技术层面来说\n以虚拟化为核心技术进行资源池化，以云管理平台对资源进行调配实现云计算的技术\n\n\n\n服务的三层平台理解\n三层模型\n\nIass\n提供底层的硬件资源\n\nPass\n提供平台应用\n\n自己的应用自动安装\n通用的应用自动安装（比如数据库，理解：虽然自己可以基于Iass层自己安装数据库，但是规模大了之后需要维护，Pass层就很好的提供了基于平台的服务，让使用公司专注于业务）\n\n所以容器技术在Pass层大放异彩，平台服务由服务商提供，公司只需要专注于业务+\n\nSass\n\n\n\n\n虚拟化技术\n是什么：   是一种资源管理技术，将资源池化。            是一种硬件和操作系统的解耦      将操作系统进行隔离\n\n对象\n针对于服务器的资源，也叫服务区虚拟化 \n\n作用：资源池化后提高了资源的利用率\n\n特点：\n\n分区\n隔离\n封装\n相对于硬件相对独立\n\n\n类型：\n\n寄居虚拟化\n在操作系统层面安装虚拟化层\n部署简单，但是性能低\nVMware\n\n\n裸金属虚拟化\nvmm层在硬件上\n性能好，但是需要对vmm层的内核进行开发 \nXen架构   华为的fushonPhere\n\n\n混合虚拟化\n在操作系统内核插入了一个虚拟化内核模块，相当于二者的结合\n性能高，开发难度小，但是需要硬件支持，需要支持虚拟化的cpu\nKVM\n\n\n\n\n架构类型\n\n全虚拟化\n\nKVM就是全虚拟化，通常为加入kvm内核模块进行虚拟化，还要配合QEMU模块进行IO虚拟化等工作\n就是混合虚拟化\n\n\n半虚拟化\n\nXen加固就是半虚拟化  通常在会有个总操作系统进行资源管理Domain0，其他资源调配需要domian0的辅助\n就是裸金属虚拟化\n\n总结：全虚拟化：方便，性能好，但是安全隔离性较差\n\n\n\n技术类型\n\n计算虚拟化\n\ncpu\n内存\nI&#x2F;O\n\n\n存储虚拟化\n\n网络虚拟化\n\n定义\n指的是微观层面的虚拟化，不是路由交换层面的网络，而是服务器网络资源等虚拟\n\n个人理解：\n\n总结下来，网络虚拟化主要解决的是虚拟机构成的网络通信问题，完成的是各种网络设备的虚拟化，如网卡、交换设备、路由设备等。 \n网络虚拟化针对的是虚拟化后的各个虚拟机间的通信。比如我的硬件虚拟出了1000台虚拟机，他们该如何交换数据，如何沟通等问题就是网络虚拟化来解决\n其中虚拟机与虚拟机之间的通信，由虚拟交换机完成，虚拟网卡和虚拟交换机之间的链路也是虚拟的链路，整个主机内部构成了一个虚拟的网络，如果虚拟机之间涉及到三层的网络包转发，则又由另外一个角色——虚拟路由器来完成。\n\n\n应用\n\n因为集成度比较高，可以单独作为一个模块，这一整套虚拟网络的模块都可以独立出去，由第三方来完成，如其中比较出名的一个解决方案就是 Open vSwitch（OVS）。 \nOVS 的优势在于它基于 SDN 的设计原则，方便虚拟机集群的控制与管理，另外就是它分布式的特性，可以「透明」地实现跨主机之间的虚拟机通信，如下是跨主机启用 OVS 通信的图示。 \n\nTAP&#x2F;TUN&#x2F;VETH、Bridge 这些虚拟的网络设备是 Linux 为了实现网络虚拟化而实现的网络设备模块，很多的云开源项目的网络功能都是基于这些技术做的，比如 Neutron、Docker network 等。\n\n\n\n\n\n\n\n\nOpenStack\n是什么？\n\n是云化管理平台，虽然KVM，XEN是开源的但是，基于这些虚拟的资源进行管理的云平台是闭源的，而openstack是第一个开源的云化管理平台\n\n\n理解：\n\n虚拟化技术将各种资源进行了池化，openstack实现了对池中资源的调度，可以类似理解为“管理云资源的操作系统”\n主要使用池化虚拟资源来构建和管理私有云及公共云\n\n\n\n","slug":"cloudComputing","date":"2021-04-26T05:48:25.000Z","categories_index":"CloudComputing","tags_index":"","author_index":"Hubert"},{"id":"0d5b4ab158060e81e0a6127529557325","title":"Net-技术拓展","content":"CGN\n定义：\n\n翻译为运营商级地址转换（运营商级NAT），又称作LSN（Large-scale NAT，大规模网络地址转换），是一种基于NAT的更高级应用技术。\n\n\n个人理解：\n\n就是使用了两次的nat地址转换\n\n\n地址分配\n\n除了分配的三类私网ip地址，还专门为CGN预留了一个 “共享地址空间”(IANA-Reserved IPv4 Prefix for Shared Address Space) ，即100.64.0.0&#x2F;10，专门用于CGN使用，以防止在第一次转换时用户的私网IP与运营商分配的私网IP产生冲突。\n\n\n应用\n\nCGN有很多应用场景，比如NAT444，还有NAT64、DS-Lite等。\n\n\n\nMPLS\n是什么\n\n是一种新型的转发技术\n\n\n概念\n\nInternet核心网中的路由&#x2F;转发技术的最新发展是多协议标签交换（MPLS）。MPLS将IP路由控制和第二层交换的简单性无缝地集成起来，是ATM与IP技术的有机结合，在不改变用户现有网络的情况下能提供高速、安全、多业务统一的网络平台，将在下一代网络中的选路、交换和分组转发中扮演非常重要的角色，满足网络用户的多种多样的需求。\n\n\n个人理解：\n\n就是将原来的路由转发模式变成了类似于二层查询的模式，从而大大的提高了网络的访问速率\n\n\n应用\n\n流量工程                    MPLS的流量管理机制主要包括路径选择、负载均衡、路径备份、故障恢复、路径优先级及碰撞等。 智能引导流量\n服务等级（CoS）     不同服务等级对应不同的流量控制\n虚拟专网（VPN）\n\n\n\nVPN\n概述\n是什么\n全称为   虚拟专用网络\n\n\n产生背景\n大概就是两个公司拉专网太贵，为了节约成本而创建的一种技术\n\n\n作用\n一般用于访问内网资源\n“fan qiang”    利用了加密技术并且访问代理服务器达到目的（但本质上还是用于内网的互通，只不过该技术的特点比较适合这个方面）\n\n\n特点\n安全 \n成本低 \n支持移动业务 \n可扩展性\n\n\n分类\nIPsec      网络层     主要是通过加密原数据包\nSSL         应用层      主要通过应用层的加密\nGRE        网络层   主要通过对原数据包进行封装\nPPTP      PPTP是对端对端协议（PPP）的一种扩展 进行隧道建立\n\n\n核心技术\n隧道技术\n身份认证、数据加密、数据验证\n\n\n\n\n个人理解：\n关于vpn，其实核心的思想应该是 隧道技术，因为隧道技术基于三层，是构建 Overlay 逻辑网络 的底层核心技术，实现了逻辑网络和物理网络的解耦，在很多云计算的网络中底层都有应用，比如vxlan，而vxlan的本质也就是通过隧道技术搭建大二层。\n\n\n\nQos\n质量服务优化\n理解：就是智能流量选择，通过标签确定流量的优先级\n\nVRRP\n虚拟路由冗余协议(Virtual Router Redundancy Protocol，简称VRRP)是由IETF提出的解决局域网中配置静态网关出现单点失效现象的路由协议，1998年已推出正式的RFC2338协议标准。VRRP广泛应用在边缘网络中，它的设计目标是支持特定情况下IP数据流量失败转移不会引起混乱，允许主机使用单路由器，以及即使在实际第一跳路由器使用失败的情形下仍能够维护路由器间的连通性。 \n\n理解：\n\n相当于将多个路由器虚拟成一个路由器，成为主备，常常用于网络的边缘接入，从而提高了网络的冗余性，\nVRRP是一种容错协议，在提高可靠性的同时，简化了主机的配置\n\n\n构成\n\n主路由器+所有备份路由器&#x3D;虚拟路由器\n\n\nVRRP路由器在运行过程中有三种状态：\n\nInitialize状态：系统启动后就进入Initialize，此状态下路由器不对VRRP报文做任何处理，可以理解为初始化\nMaster状态：路由器会发送VRRP通告，发送免费ARP报文。\nBackup状态：接受VRRP通告。\n\n一般主路由器处于Master状态，备份路由器处于Backup状态。 \n\n优先级选举：\n\nVRRP组中IP拥有者。如果虚拟IP地址与VRRP组中的某台VRRP路由器IP地址相同，则此路由器为IP地址拥有者，这台路由器将被定位主路由器。\n比较优先级。如果没有IP地址拥有者，则比较路由器的优先级，优先级的范围是0~255，大的作为主路由器\n比较IP地址。在没有Ip地址拥有者和优先级相同的情况下，IP地址大的作为主路由器。\n\n\n主备替代过程\n\n第一种：收到路由通告等级低的时候，会延时抢占\n第二种：连续三次没有收到路由通告，自动变成猪备份\n\n\n\n","slug":"net2","date":"2021-04-26T05:48:25.000Z","categories_index":"Net","tags_index":"","author_index":"Hubert"},{"id":"a64196a02ebbcb9126814b321ce99582","title":"Java-面对对象","content":"面对对象类\n方法\n\n\n\n\n\n\n\n\n\n\n方法的参数传递问题\n\n传递基本数据类型和引用数据类型的区别\n传递可变参数\n\n\n方法的重载\n就是相同的方法中，只有参数不同，从而匹配不同的同名方法。\n\n\n\n构造方法（构造器）\n\n\n\n\n\n\n\n\n\n\n注意会默认调用父类的构造器，所以子类在实例化的时候要注意\n\n\n\n抽象类\n理解：因为类可以被继承，并且子类可以对父类的方法进行重写，由此可以演进出以父类为模板的，子类来实现的模式，而抽象类可以作为模板\n\n抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 \n\n注意事项：\n\n\n\n\n\n\n\n\n\n\n抽象类和抽象类的方法用abstract修饰,抽象方法没有代码体\nabstract class Person &#123;\n    public abstract void run();\n&#125;\n\n继承的子类必须重写抽象类的所有方法\n\n有抽象方法的类必须是抽象类，抽象类的方法不一定是抽象方法\n\n\n\n\n接口\n本质：比抽象类还要抽象的纯抽象接口 ，一个抽象类没有字段，所有方法全部都是抽象方法的抽象类\n\ndefault方法？  接口新增方法，无需重写全部子类\n\n接口内部除了方法，还可以存在静态变量\npublic interface Person &#123;\n    public static final int MALE &#x3D; 1;\n    public static final int FEMALE &#x3D; 2;\n&#125;\n但可以被简写\npublic interface Person &#123;\n    &#x2F;&#x2F; 编译器会自动加上public statc final:\n    int MALE &#x3D; 1;\n    int FEMALE &#x3D; 2;\n&#125;\n\n包\n包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。\n\n封装\n通过private将变量隐藏，再通过方法进行操作\n\n继承\n使用extends关键字进行类的继承\n\nsuper关键字\n\n\n\n\n\n\n\n\n\n子类构造器第一行有默认super（）调用父类的构造器，所以继承时，子类的构造器要注意super参数的传递问题\n\n向上转型和向下转型\n向上转型：父类类型的变量指向子类的实例，是安全的\n向下转型：实际上是强制类型转换，不安全，需要进行instanceof进行判断后才行，否则报ClassCastException 错误\n\n方法的重写\n就是子类中重新编辑父类中的某个方法，子父类中的方法要严格相同，不相同就是重载\n\n\n多态：\n多态体现为父类引用变量指向子类对象。\nJava的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。 \n\n多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。\n\n\n","slug":"java2","date":"2021-04-11T05:48:25.000Z","categories_index":"Java","tags_index":"","author_index":"Hubert"},{"id":"a293d787cf7979f11b343b04086d0db9","title":"Net-网络基础","content":"TCP&#x2F;IP体系知识应用层\n实际上是和应用打交道，是对相互通信进程之间交换的信息的一种规范\n\n应用层协议：就是规定了交换信息的格式\n具体协议\nHTTP协议\n\n用于web的一种协议\n请求格式\n响应格式\n\n\nHTTPS\n\nHTTP+TLS\nTLS加密方式：\n对称加密                   ：收发同时使用公钥进行加解密\n非对称加密                ： 公钥加密，私钥解密。而私钥只有自己知道   （耗费资源）\n\n\n加密过程     \n首先通过非对称方式的到会话秘钥，这个秘钥只有收发两方知道\n在通过会话秘钥进行对称加密\n\n\n\n\nDHCP协议\n\n动态主机配置协议\n\n作用： 动态的为主机配置ip，网关以及dns服务器地址\n\n配置类型\n\n手动配置\n自动配置\n动态配置\n\n\n请求流程：（第一次分配）\n\n客户端发送DHCP_DICOVER\n\n发送广播，源ip为0.0.0.0（如果没有回应，依次以2 4 8 16）发送\n如果得到了地址就成功，没有得到会自己设置个临时地址，然后个5分钟广播一次\n\n\n服务器发送DHCP_Offer\n\n此时服务器端仍然发送的是广播，但mac会封装对方的mac以及用XID编号进行封包\n\n\n客户端发送DHCP_Request\n\n客户端对可能发来的多条offer选择一个，仍然以源ip为0.0.0.0 进行发送广播\n\n\n服务器端DHCP_ACK\n\n服务器端对其进行确认\n\n\n\n\n通过租约和续约来进行ip地址的请求\n\n第n次登陆后，只需要发送DHCP—Request进行确认即可\n\n\n\nFTP\n\n文件传输协议\n具有两个TCP连接   21端口控制连接       20端口数据连接\n传输模式\n主动传输\n被动传输\n\n\n\n\nDNS\n\n查询过程\n首先在电脑本地的缓存器查找\n再通过递归查询本地dns服务器\n本地dns服务器和其他服务器进行迭代查询\n\n\n域名结构\n顶级域名\n二级域名\n每个分级的服务器都有缓存\n\n\n\n\n\n\n\n\n\n运输层\n连接端到端\n\nTCP：6\n个人理解：在网络传输的过程中，起到的类似于控制和规划的作用，让网络传输的效率达到最大\n\n三次握手，四次挥手\n\nTCP窗口\n\n发送窗口影响机制（多包）\n\n接收窗口大小\n网络拥塞程度\n该因素反应的是网络的堵塞程度，会有拥塞窗口来限制MSS\n\n\n\n\n可靠传输\n\n利用滑动窗口机制，通过发送窗口和接收串口的反复确认来可靠传输\n\n\n流量控制\n\n目的：防止接收方接收数据溢出\n\n原理：\n通过滑动窗口机制进行流量控制\n主要是通过接收方的rwnd对发送方的发送窗口大小进行调整，从而不让发送方发送过快而导致接收方溢出\n\n\n\n拥塞控制\n\n原理：通过设置拥塞窗口的值来限制发送窗口的大小\n作用：让网络的吞吐量一直保持最大值\n算法：\n慢开始\n拥塞避免\n快重传                  收到连续三个请求后，不会等待重传计数器的时间，直接发送报文段\n快恢复                  收到三个确认后吧慢门限减半\n\n\n\n\n\nUDP：17TCP和UDP区别：\nTCP面向连接，UDP无连接\nTCP一对一，UDP支持一对一，一对多，多对一\nTCP是面向字节流，UDP是直接封装头部\nTCP可靠，UDP不可靠\nTCP首部20到60字节，UDP只有8个字节\n\n网络层  ：\n通过IP地址实现各个网络的互联\n\n路由器\n功能\n路由选择\n通过相关协议的选择，rip，ospf，bgp等实现相关路由的计算得出路由表\n\n\n功能转发\n通过查找路由表对相关数据包进行转发\n\n\n路由表： 目的网络   下一跳      接口    度量值\n\n\n\nICMP（网际控制报文协议）\n干什么：用来发送差错报告报文和询问报文\n\n差错报文分类\n\n询问报文：\n\n回送请求和回答\n时间戳请求和回答\n\n\n应用\n\nping\nping的使用\n检查网络的连通性\n检查网络连通的质量（拥塞程度）\n可以 ping  -t   一直对目标网络进行测试，查看网络情况，比如看网络的拥塞程度和连接程度\n\n\n判断目的主机的系统类型，因此一般TTL值：\n100~130ms之间，Windows系统 ；\n240~255ms之间，UNIX&#x2F;Linux系统。\n\n\nping -r 显示出路径\nping -n 设置平均发送的包\nping -l 6550 设置ping发的包的大小\n\n\n\n\ntracert\n原理：通过逐次增加报文的ttl时间然后通过差错返回报文进行判断\n\n\n\n\n\nARP\n是什么\n地址解析协议（Address Resolution Protocol）    通过ip地址来解析mac地址\n\n\n分类\n静态            手动配置\n动态            自动更新配置\n\n\n免费arp\n主要是发送自己的ip地址来获得自己的mac地址\n作用\n系统引导时的更新配置\n检测局域网内是否发生了ip冲突\n更新其他主机的缓存表\n\n\n\n\n代理arp\n主机没有配置网关时，来自路由器的善意欺骗，返回的mac地址是路由器的mac地址\n主要是针对于没有配置网关的电脑实现路由互通\n当主机有网关时，发现目标ip不在同一个网段，会直接封装网关的mac地址\n总结：代理arp和正常arp主要是使用场景的差别\n电脑没有网关时，ARP直接询问目标IP对应的MAC地址（跨网段），采用代理ARP；\n电脑有网关时，ARP只需询问网关IP对应的MAC地址（同网段），采用正常ARP；\n无论是正常ARP还是代理ARP，电脑最终都拿到同一个目标MAC地址：网关MAC。\n\n\n\n\narp攻击\n本质是一种欺骗，中间人攻击  原则是  后到优先\n\n\n\n防火墙\n是什么？\n\n防火墙是一种安全设备，保护一个网络区域免受另一个网络区域的攻击和入侵，通常被部署在网络边界，例如：企业互联网出口；\n\n\n作用：\n\n基本功能 （狭义的防火墙）\n区域隔离和访问控制 （访问控制可以产生会话）           路由器虽然也有基本的功能，但是不够强大\n\n扩展功能   （广义的防火墙）\n文件过滤，内容过滤，入侵防御isp  —————–但是这些功能对于防火墙开销比较大\n\n\n\n安全区域：\n\n通过将防火墙不同端口连接不同网络来划分安全区域，提高了隔离性，从而增加了安全性\n默认分类：\n受信区域                           不需要通过检测\n非受信区域            \n非军事化区域（公共互联网区域）\n本地区域（local）\n\n\n\n\n匹配策略：\n\n安全策略由匹配条件、动作组成 \n\n匹配条件：\n\n五元组（源地址、目的地址、源端口、目的端口、协议）\n目的安全区域、用户、时间段等\n\n\n动作\n\n拒绝\n通过\n\n\n\n\n会话表\n\n作用：记录协议连接状态\n理解：比如tcp三次握手连接等情况，如果每次都进行匹配策略以及其他的流程检测，则会大大降低效率，所以通过首包建立会话表来记录连接状态\n会话表老化时间\n若会话表长时间不匹配，则会占用防火墙资源，所以超过老化时间会自动清理会话表\n但是：想FTP等协议报文间隔时间较长，则会设置长连接避免会话表被删除\n\n\n\n\n\nNAT\n是什么：\n是一种ip地址转换技术，用于ip地址枯竭问题\n\n\n作用：\n节约了ip地址\n提高了安全性，隐藏了内网地址\n\n\n分类\n静态NAT   （内外网ip地址一对一转换，没有解决地址紧缺的问题）\n动态NAT     （通过创建IP地址池，使用时利用池里面的ip地址池进行匹配，一定程度上的缓解紧缺问题）\nNAPT    （利用ip地址和端口进行转换，做到了一对多的形式，解决了地址紧缺问题）\n\n\n\n数据链路层交换机\n作用：\n汇聚\n隔离冲突域\n寻址和转发\n\n\nmac表的自学习过程\n通过将接受的数据帧的端口与源mac地址进行关联\n\n\n\n链路聚合\n定义理解: 将多条链路聚合为一条逻辑链路。\n\n基本概念：\n\n链路聚合组（LAG）\nEth-trunk（链路聚合组接口）\n成员接口\n活动接口（提供了带宽）\n非活动接口（提供了冗余可靠性）\n\n\n成员链路\n\n\n优点：\n\n增加带宽\n增加可靠性\n负载均衡\n\n\n设备的链路聚合方式：\n\n同一设备\n堆叠设备\n跨设备（基于LACP模式）\n\n\n聚合模式：\n\n手动聚合： 就是用手工来配置         （只能解决断路等简单故障）\n\n全部链路进行流量分发\n\n\nLACP                                                   （可以动态的解决更多链路故障）\n\n链路聚合控制协议 LACP \n\n理解：就是动态的维护链路状态\n\n\n优先级：\n\n系统优先级： 因为接口两端要相同，所以以优先级高的为接口标准，优先级低的同步优先级高的接口，以优先级高的为模板\n，数字越大，优先级越小\n\n接口优先级：成员接口的优先级越高，优先被选为活动接口。（数值越大，优先级越低）\n\n\n\nM：N备份\n\nM个活动链路，N个非活动接口\n\n\n实现原理：\n\n通过交换链路聚合控制协议数据单元LACPDU与对端交互信息，确定聚合端口\n\n\n\n\n\n\n\n","slug":"net3","date":"2021-04-10T05:48:25.000Z","categories_index":"Net","tags_index":"","author_index":"Hubert"},{"id":"6680b6536ab34550098dc51e7750bdac","title":"Net-路由协议","content":"路由协议总述\n动态路由协议\n\n\nIGP（内部网关协议）  主要为路由发现和计算\nRIP\nOSPF\n\n\nEGP（外部网关协议）  主要为路由选择和控制\nBGP\nEBGP\nIBGP\n\n\n\n\n\nOSPF：\n开放最短路径优先，IP传输，使用的协议号为89\n\n因为是采用了IP协议传输，所以OSPF在网络层来看本身不可靠，所以采用了定时更新策略，但是采用了主从选举机制，增加了可靠性\n思考： 为什么rip再用UDP，ospf采用IP，BGP采用TCP\n首先rip是从历史的原因出发，当时的运输层和IP层的规划还没有很清晰，规则制定不完全，加上rip是个进程所以采用udp，但是这个原因不绝对，采用upd只能是当时最优的选择，而OSPF是内部网关协议，AS内部经常会出现网络状况的变动，在网络规划发展越来越清晰后，通过IP层，减少了层数，提高了效率和容错率，在区域内部基于ip是更优解。但是BGP采用TCP，因携带的路由信息较多，且可能跨不同网络传送路由信息，为保证可靠性，需使用TCP协议，可兼顾容量和可靠性\n\n\n\n\nospfV2和ospfV3的区别\n\nv2是基于ipv4\nv3是基于ipv3\n\n\n邻居关系的建立：\n\n发现邻居\n建立邻接关系\n更新数据库分组信息\n计算路由\n\n\n3大特点：\n\n基于链路状态\n链路状态也是接口状态，具体的开销实则基于带宽因素。cost &#x3D; 10的八次方&#x2F;带宽，\n\n\n规模不受限制\n通过AS内划分区域，可以提高AS的容量上限，也就是层次性的网络结构 \n区域内选举DR&#x2F;BDR，减少网络洪范开销\n\n\n避免成环\n区域内采用stp算法，生成无环路的树\n区域间采用水平分割，非骨干区域只能连接到骨干区域\n浅析：\n其中，在区域间采用水平分割的方式中，非骨干区域和骨干区域的连接不是实际上的邻接关系，而是通过虚链路建立的逻辑邻接关系\n\n\n\n\n\n\n4大定义网络类型\n\n点对点（P2P）\n\n非广播，多路访问网络（NBMA）\n\n广播网络（主流）\n\n点对多点网络（P2MP）\n\n浅析：为什么要定义4大网络类型？\n\n从历史发展的角度：\n\n\n\n\n\n\n\n\n\nOSPF诞生于九十年代，那个时候除了以太网（双绞线）之外，还有各种稀奇古怪的网络，比如串行链路等等，这些网络现在已经很难见到了，但当时是有的，甚至在有些地方是很多的。\n所以设计一个路由协议，必须要考虑这些应用场景，否则这个协议就会有推广上的限制。\nP2P&#x2F;NBMA&#x2F;P2MP这些都是为了适应当时的需要设计的。\n现在以太网几乎一统天下，广播网络大行其道，自然也就没有其它网络类型的事情了。但作为兼容性，一直就保留下来了。\n\n从技术角度\n\n\n\n\n\n\n\n\n\n在某些特定场合比较合适\n\n\n\n\n\n5大分组\n\nhello分组\n用于邻居发现，发送周期为10s，40s没回应即为不可达\n目的ip为224.0.0.0.5\n\n\n数据库描述分组\n链路状态请求分组\n链路状态宣告分组（LSU），进行洪范发送\n链路状态确认\n\n\n8大状态机\n\nDown:此状态还没有与其他路由器交换信息。 \nAttempt: 只适于NBMA网络（该网络没有广播能力，只能手动建立邻接关系） \nInit: 表明收到了Hello包,但是2-Way通信仍然没有建立起来 \ntwo-way: 双向会话建立,而 RID 彼此出现在对方的邻居列表中。(若为广播网络：例如：以太网。在这个时候应该选举DR,BDR。) \nExStart: 信息交换初始状态 （主从选举机制（RouterID大的为主，小的为从，侧面为OSPF提供了可靠性），主先发DBD，从后发DBD）\nExchange: 信息交换状态 （交换BDB）\nLoading: 信息加载状态 （发送LSR请求最新LSA ）\nFull: 完全邻接状态\n\n\n区域\n\n划分区域的意义\n\n降低了路由计算的频率的频率\n减少了路由表\n减小了链路状态更新报文（LSU）的流量\n\n\n区域内的DR，BDR\n\n选举后的洪范地址\nDR&#x2F;BDR的发送的OSPF包的目标地址为224.0.0.5;而除了DR&#x2F;BDR以外的OSPF包的目标地址为224.0.0.6\n\n\n\n通过内部选举出DR，BDR，让非dr&#x2F;bdr的路由器和其进行建立邻接关系，从而减小了网络的开销\n选举规则：\n手动选举：首先根据优先级大的为dr（路由器默认为1，为0 的不能作为DR&#x2F;BDR）相同优先级的情况下比较  router-id\n自动选举： router-id最大的为DR，其次为BDR\n\n\n\n\n区域的划分：\n\n骨干区域\n标准区域\n末梢区域\n区域内除了域内路由外，只有区间路由，所以够进入或存在Stub区域的链路状态通告LSA的类型为1、2、3型，禁止4、5、7型进入Stub区域。  （区域内只能有域内路由，AS路由）\n\n\n完全末梢区域\n区域内除了域内路由外，只有一个默认路由（即LSA3只能开启默认路由功能）\n\n\n非完全末梢区域\n\n\n\n\nAS的路由器分类\n\n内部路由器（Internal Router）\n区域边界路由器（Area Border Routers，ABR）\n是指连接一个或多个区域到骨干区域的路由器，并且这些路由器会作为域间通信量的路由网关。\n\n\n自治系统边界路由器（Autonomous System Boundary Router，ASBR）\n是OSPF域外部的通信量进入OSPF域的网关路由器\n\n\n\n\n通信量分类\n\nIntra-Area Traffic:域内间通信量\nInter-Area Traffic:域间通信量\nExternal Traffic:外部通信量\n\n\nospf需要的三张表\n\n路由表\n邻接表\n数据库信息表\n\n\nLSA的分类  总共有11种，但是因为报文编码的问题，有的交换机不支持，所以常用的有6种\n\n总共有六大类\n\n\nLSA1：**(Router LSA)**         区域内所有路由器产生    \n每一台运行OSPF路由协议的路由器都会产生路由器LSA通告。这个最基本的LSA通告列出了路由器所有的链路或接口，并指明了它们的状态和沿每条链路方向出站的代价。这些LSA通告只会在始发它们的区域内部进行泛洪。\n\n\nLSA2：**(NetWork LSA)**    区域内的DR产生               \n每一个多址网络（广播型和NBMA）中的指定路由器DR都将会产生网络LSA通告。可将DR路由器看做一个“伪”节点或一个虚拟路由器，用来描绘一个多址访问网络和与之相连的所有路由器。\n\n\nLSA3: （Network Summary LSA）区域内的ABR产生                      产生的是路由信息，不是链路状态信息，描述区域间的路由\n网络汇总LSA就是ABR 路由器告诉在自己所属区域内的内部路由器它所能到达的目的地址，一般用于描述区域间路由\n\n\nLSA4：（ASBR Summary LSA） ABR产生           \nLSA4通告的目的地仅仅是一个ASBR路由器，相当于目的仅仅是一个具体的路由器，而不是网络，告诉外部路由位置\n\n\nLSA5：**（External LSA） **      ASBR产生        描述区域外的路由     不包括末梢和完全末梢区域\n\n\n用来通告到达OSPF自治系统外部的目的地或者是到OSPF自治系统外部的默认路由的LSA。通告将在整个自治系统中进行泛洪\n\n\nLSA7：ASBR产生                         描述区域外的路由   只包括非完全末梢区域\n\n\n\nBGP：\nBGP是建立在TCP连接之上  端口号为179\n\n因为采用tcp，所以可靠，采用触发更新\n\n\n特点：\n\nBGP是一种外部网关协议，BGP不产生路由，只传递路由，并且具备丰富的路由策略。 \nBGP使用TCP作为其传输层协议（端口号179）,提高了协议的可靠性； \nBGP是一种增强距离矢量路由协议，从设计上避免了环路\n把一个AS看做路由器，来记录跳数\n避免环路：\nAS之间： 会携带途径AS的标记，如果发现本地标记，则会丢弃\nAS内部：水平分割\n\n\n\n\nBGP采用触发式增量更新\n触发：基于TCP的安全连接  增量：基于BGP要承载大量路由信息，无法全部更新\n\n\n\n\n分类\n\nEBGP（不同的AS）  通常为物理连接\nIBGP（相同同的AS）\n\n\n基本概念：\n\nBGP发言人\nBGP对等体\n关于建立邻居关系：建立IBGP邻居关系是时，一般使用loopback接口的IP地址，因为loopback接口开启后一直处于UP状态，只要保证路由可达，邻居关系就会处于稳定状态。而建立EBGP邻居关系时，一般使用直接接口的IP地址，因为EBGP是跨AS建立邻居关系，邻居关系建立之前非直连接口之间的路由不可达\n对等体建立过程\nTCP建立连接\n发送open报文\nopen报文内容：\n自身AS\n版本：通常为4\nhold time\nrouter id\n\n\n\n\nkeepalive报文（用于保持连接）\n路由通告\n\n\n\n\n\n\n5种BGP报文：\n\nBGP存在5种不同类型的报文，分别是：\nopen：   用于协商参数 \nupdate： 用于在对等体之间交换路由信息。 \nnotification：当BGP检测到错误状态时，就会向对等体发送Notification报文，告知对端错误，之后BGP连接会立即中断。 差错通知\nkeepalive：双方相互发送keepalive报文，收到对方的keepalive报文后对等体建立成功，同时后续定期发送keepalive报文用于保持连接。 \nroute-refresh：于在改变路由策略后请求对等体重新发送路由信息。 \n其中 keepalive 为周期更新，其余为触发更新\n\n\n\n\n6种状态机\n\nIdle 状态 ：是 BGP 初始状态。在 Idle 状态下， BGP 拒绝邻居发送的连接请求 （一般如果遇到失败对话体的建立都会回到Idle状态）\nConnect 状态， BGP 启动连接重传定时器（Connect Retry），等待 TCP 完成连接。 （ TCP 连接失败，那么 BGP 转至 Active 状态）\nActive 状态， BGP 总是在试图建立 TCP 连接。 \nOpenSent 状态， BGP 等待对等体的 Open 报文 \nOpenConfirm 状态， BGP 等待 Keepalive 或 Notification 报文。 \nEstablished 状态， BGP 可以和对等体交换 Update、 Keepalive、 Route-refresh 报文和Notification 报文。\n\n\n\n\n\n","slug":"net1","date":"2021-04-08T05:48:25.000Z","categories_index":"Net","tags_index":"","author_index":"Hubert"},{"id":"f074b92e2bf809e27da1254814ebde33","title":"Java-字符串","content":"String类\nString\n\n创建的两种方法以及原理浅析：（重点）\n\n直接创建\n构造函数创建\n\nString s1 &#x3D; &quot;Runoob&quot;;              &#x2F;&#x2F; String 直接创建\nString s2 &#x3D; &quot;Runoob&quot;;              &#x2F;&#x2F; String 直接创建\nString s3 &#x3D; s1;                    &#x2F;&#x2F; 相同引用\nString s4 &#x3D; new String(&quot;Runoob&quot;);   &#x2F;&#x2F; String 对象创建\nString s5 &#x3D; new String(&quot;Runoob&quot;);   &#x2F;&#x2F; String 对象创建\n\n\n三个空间： 字符串常量池 （存放字符串的值）  堆（存放对象）  栈（存放变量名）\n\n\n引用对象在编译器无法确定，只能在运行期确定，所以引用对象相加会在堆空间创建新对象\n\n\n总结\n\nString s1 &#x3D; “a”;  说明：在字符串常量池中创建了一个字面量为”a”的字符串。\n\ns1 &#x3D; s1 + “b”;  说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符 串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本 字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响 程序的性能。\n\nString s2 &#x3D; “ab”; 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。\n\nString s3 &#x3D; “a” + “b”; 说明：s3指向字符串常量池中已经创建的”ab”的字符串。\n\nString s4 &#x3D; s1.intern(); 说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串 赋值给s4。\n\n\n\n\n\n特点：\n\n\n“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。\n\n\n和其他类型数据进行转换\n\n字符数组 —&gt; 字符串\nString s &#x3D; new String(数组名称);\n\n字符串—&gt; 字符数组\n\n\n  char[] arr &#x3D; str.toCharArray()\n\n\nString —&gt;基本数据类型，包装类\n\n包装类.parse基本数据类型（字符串）\n\n&#96;&#96;&#96;javaint num &#x3D; Intenger.parseInt（s）\n\n- 基本数据类型，包装类 ---&gt;String\n\n  - String.valueOf(基本数据，包装类)\n\n  - &#96;&#96;&#96;java\n    String.valueOf(基本数据，包装类)\n\n\n\n\n相关方法 （别无他法，只能多用，多记，多做）\n\n\n\n\n\n\n\n\n\n\nint length()：返回字符串的长度： return value.length\n\nchar charAt(int index)： 返回某索引处的字符return value[index]\n\nboolean isEmpty()：判断是否是空字符串：return value.length &#x3D;&#x3D; 0\n\nString toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写\n\nString toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写\n\nString trim()：返回字符串的副本，忽略前导空白和尾部空白\n\nboolean equals(Object obj)：比较字符串的内容是否相同\n\nboolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写\n\nString concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”\n\nint compareTo(String anotherString)：比较两个字符串的大小\n\nString substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。\n\nString substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。\n\nboolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束\n\nboolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始\n\nboolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始\n\nboolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true\n\nint indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引\n\nint indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始\n\nint lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引\n\nint lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索\n\n\n​    注：indexOf和lastIndexOf方法如果未找到都是返回-1\n\nString replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。\n\nString replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。\n\nString replaceAll(String regex, String replacement) ： 使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。\n\nString replaceFirst(String regex, String replacement) ： 使 用 给 定 的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式\n\nString[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。\n\nString[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。\n\n\n\n\n\nStringBuilder \n\n它是一个可变对象，可以预分配缓冲区 ，相比于与String，不需要清除空间并且重新写入，而是在原来空间进行修改\n\n可以链式调用， 因为调用方法后返回了 this 即返回了对象\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        var sb = new StringBuilder(1024);\n        sb.append(&quot;Mr &quot;)\n          .append(&quot;Bob&quot;)\n          .append(&quot;!&quot;)\n          .insert(0, &quot;Hello, &quot;);\n        System.out.println(sb.toString());\n    &#125;\n&#125;\n\n\n线程不安全\n\n\n\nStringBuffer是Java早期的一个StringBuilder的线程安全版本\n\n\n\n\n","slug":"java4","date":"2021-04-05T05:48:25.000Z","categories_index":"Java","tags_index":"","author_index":"Hubert"},{"id":"fc1d81b19b3e79145fb3db27c32bb9d6","title":"Java-数组","content":"\n数组（掌握操作方法）\n\n数组是用来存储固定长度的同类型元素 \n\n注意：\n如果存储的为引用数据类型时，改变值时，实际是创建新的值并改变指针指向（常见于字符串数组，因为字符串无法改变）\n所以关于字符串数组排序后，改变的不是值的顺序，而知指针的顺序\n\n\n\n\n数组的操作\n\n定义\nint[] arr &#x3D; new int[9];\n\nint [] ar &#x3D; &#123;1,2,3,4,5,6&#125;;  &#x2F;&#x2F;初始化\n\n相关类（Arrays）进行操作\n\nArrys.equals(long[] a, long[] a2)\n\n判断两个数组是否相等\n\n\nArrys.fill(int[] a, int val)     在数组中填充相同数字\nArrays.fill(nums, 1);\n\nArrays.fill(nums,2,5,3);\n&#x2F;&#x2F;对数组的部分元素填充一个值,从起始位置到结束位置，取头不取尾\n\nArrys.sort(Object[] a)      \n\n为数组进行排序（升序）\n\nArrays.sort(nums, 0, 4);  指定索引进行排序\nArrays.sort(nums);  &#x2F;&#x2F;全部排序\n\nArrays.toString(Object[] array) \n\n实际作用是方便的显示数组，不需要用循环遍历再去显示数组内容\n\n int[] lsit &#x3D; &#123;3,8,5,65,34,27&#125;;\nSystem.out.println(list.toString()); &#x2F;&#x2F;打印数组地址\nSystem.out.println(list）;           &#x2F;&#x2F;打印数组地址\nSystem.out.println(Arrays.toString(array)); &#x2F;&#x2F;打印数组内容\n\nArrays.deepToString(Object[][] arrays) \n\n显示多维数组\n\n\nArrys. binarySearch(Object[] a, Object key) \n\n返回相应值的索引\n\n\n\n\n遍历\n\n\n\n\n\n\n\n\n\n\nfor\n\nfor each\nfor(type element: array)\n&#123;\n    System.out.println(element);\n&#125;\n\n\n排序\npublic class Sort &#123;\n&#x2F;&#x2F;冒泡排序\n    static void sort_maopao(int[] arg)&#123;\n\n        for (int i &#x3D; 0; i &lt; arg.length-1; i++) &#123;\n            for (int j &#x3D; 0; j &lt; arg.length-i-1; j++) &#123;\n                if (arg[j]&gt;arg[j+1])&#123;\n                    int temp;\n                    temp &#x3D; arg[j];\n                    arg[j] &#x3D; arg[j+1];\n                    arg[j+1] &#x3D; temp;\n                &#125;\n\n            &#125;\n\n        &#125;\n\n    &#125;\n&#x2F;&#x2F;选择排序\n    static void sort_select(int[] arg)&#123;\n        for(int i&#x3D;0; i&lt;arg.length-1;i++)&#123;\n            int min &#x3D; i;\n            for (int j&#x3D;i+1;j&lt;arg.length;j++)&#123;\n                if (arg[min] &gt; arg[j])&#123;\n                    min &#x3D; j;\n                &#125;\n            &#125;\n            if(i !&#x3D; min)&#123;\n                int temp;\n                temp &#x3D; arg[min];\n                arg[min] &#x3D; arg[i];\n                arg[i] &#x3D; temp;\n            &#125;\n\n        &#125;\n    &#125;\n&#x2F;&#x2F;插入排序    \n    static void sort_insert(int[] arg)&#123;\n        for (int i &#x3D;1;i &lt;arg.length;i++)&#123;\n            int value &#x3D; arg[i];\n            int position &#x3D;i;\n            while (position &gt;0 &amp;&amp; arg[position-1] &gt; value)&#123;\n                arg[position] &#x3D; arg[position - 1];\n                position--;\n            &#125;\n            arg[position] &#x3D; value;\n        &#125;\n    &#125;\n&#x2F;&#x2F;快速排序\n    static void sort_quick(int[] arg, int left, int right)&#123;\n        if (left &lt; right)&#123;\n            int mid &#x3D; get_mid(arg,  left,  right);\n            sort_quick(arg,left,mid-1);\n            sort_quick(arg,mid+1,right);\n        &#125;\n    &#125;\n\n    static int get_mid(int[] arg, int left, int right)&#123;\n        int pivot &#x3D; arg[left];\n        while (left &lt; right)&#123;\n            while (left &lt;right &amp;&amp; arg[right]&gt;pivot)&#123;\n                right--;\n            &#125;\n            arg[left] &#x3D; arg[right];\n            while (left &lt;right &amp;&amp; arg[left] &lt;pivot)&#123;\n                left++;\n            &#125;\n            arg[right] &#x3D;arg[left];\n        &#125;\n        arg[left] &#x3D; pivot;\n        return left;\n    &#125;\n\n&#125;\n\n\n\n查找\n\n&#x2F;&#x2F;二分查找\nstatic int  binary_search(int[] list,int left, int right, int value)&#123;\n        int mid &#x3D; (right - left);\n        if (left &gt; right)&#123;\n            return -1;\n        &#125;else if(list[mid] &gt; value)&#123;\n            right &#x3D; mid -1;\n        &#125;else if(list[mid] &lt; value)&#123;\n            left &#x3D; mid +1;\n        &#125;else &#123;\n            return mid;\n        &#125;\n        return binary_search(list, left, right, value);\n    &#125;\n\n\n\n\n\n","slug":"java3","date":"2021-04-03T05:48:25.000Z","categories_index":"Java","tags_index":"","author_index":"Hubert"},{"id":"692cbbd364f9e57a101941da13c61916","title":"Java-基础语法","content":"持续更新中….\n基础语法\n一个基本的java程序\n\n\n\n\n\n\n\n\n\n\n程序入口规范\nJava入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。\n\n类class名首字母大写\n\n\n\n内存示意图\n\n\n运算的准确性\n\n首先关于数字的表示，整数部分因为十进制和二进制可以对等转换，所以是准确的，但是浮点数可能因为和二进制转换的问题，导致无法精准的计算\n\n\n\n\n\n\n\n\n\n所以在浮点数的计算结果判断上面要用近似值进行判断\nMath.abs(浮点数-目标浮点数)&lt;0.00001\n\n关于类型转换，存在于两个数运算之间，而不是整个算式\n\n\n\n\n\n\n\n\n\ndouble d &#x3D; 1.2 + 24 &#x2F; 5; &#x2F;&#x2F; 5.2\n\n\n\n三元运算符\n\n三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果 \n\n转义字符\n\n\\&quot; 表示字符&quot;\n\\&#39; 表示字符&#39;\n\\\\ 表示字符\\\n\\n 表示换行符\n\\r 表示回车符\n\\t 表示Tab\n\\u#### 表示一个Unicode编码的字符\n%%   表示%\n\n\n数据类型\n\n基本数据类型\n数值\nbyte （8位，有符号，-128—127，默认为0）\nshort（16位）\nint（32位） \nlong（64位） \nfloat（32位）\ndouble（64位）\n\n\n字符（char 16位）\n布尔（boolean 默认为false）\n\n\n引用数据类型\n类\n接口\n数组\n\n\n\n\n变量类型\n\n类变量（用static进行修饰，就是静态变量，属于类，随着类的创建进行加载）\n\n\n\n\n\n\n\n\n\n\n主要申明为常量\n\n\n实例变量（对象变量，属于对象）\n\n\n\n\n\n\n\n\n\n\n就是类的属性\n访问修饰符可以修饰实例变量；\n有默认值，不需要进行初始化\n对于方法，代码块，构造器内部是可见的\n\n\n局部变量\n\n\n\n\n\n\n\n\n\n\n在方法，代码块，构造器中\n没有默认值，需要进行初始化\n因为在方法，代码块，构造器中，所以不能被访问修饰符进行修饰\n\npublic class Variable&#123;\n  static int allClicks&#x3D;0;    &#x2F;&#x2F; 类变量\n\n  String str&#x3D;&quot;hello world&quot;;  &#x2F;&#x2F; 实例变量\n\n  public void method()&#123;\n\n  int i &#x3D;0;  &#x2F;&#x2F; 局部变量\n  &#125;\n&#125;\n\n理解总结：\n\nJava 中静态变量和实例变量区别\n静态变量属于类，该类不生产对象，通过类名就可以调用静态变量。\n实例变量属于该类的对象，必须产生该类对象，才能调用实例变量。\n\n\n局部变量要进行初始化\n\n\n\n\n修饰符\n\n访问修饰符\n\n\n\n\n\n\n\n\n\n\npublic 意味着任何地方的其他类都能访问。\ndefault 则是同一个包的类可以访问。\nprotected 表示同一个包的类可以访问，其他的包的该类的子类也可以访问。\nprivate 表示只有自己类能访问。\n\n\n非访问修饰符\n\n\n\n\n\n\n\n\n\n\nstaic (修饰类方法和类变量) \n对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。\n\nfinal\n用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 \n\nabstract （用来创建抽象类和抽象方法 ）\n如果一个类包含抽象方法，那么该类一定要声明为抽象类\n\n\n\n总结\n访问修饰符\n\nJAVA 的类（外部类）有 2 种访问权限: public、default。\n而方法和变量有 4 种：public、default、protected、private。\n\n\n修饰符：abstract、static、final\n\nabstract: 表示是抽象类。 使用对象：类、接口、方法\nstatic: 可以当做普通类使用，而不用先实例化一个外部类。（用他修饰后，就成了静态内部类了）。 使用对象：类、变量、方法、初始化函数（注意：修饰类时只能修饰 内部类 ）\nfinal: 表示类不可以被继承。 使用对象：类、变量、方法\n\n\n\n\n流程控制\n\n循环：\n\nwhile 循环\ndo…while 循环\nfor 循环\nfor each循环（针对数组）\n注意：\nbreak\ncontinue\n\n\n\n\n判断：\n\nif…else语句      （二选一）\n\nif…else if…else 语句   （多选一）\n\n\n\n输入和输出\n\n输出\n\nSystem.out.println()        换行输出\nSystem.out.print()           不换行输出\nSystem.out.printf(“%.2f\\n”, d); &#x2F;&#x2F; 显示两位小数3.14               格式化输出\n\n\n输入\n\n创建Scannner对象，调用scanner的nextxxx方法**(输入不能带空格)**\npublic static void main(String[] args) &#123;\n        Scanner scanner &#x3D; new Scanner(System.in);\n        System.out.println(&quot;请输入这次成绩&quot;);\n        int now &#x3D; scanner.nextInt();\n        System.out.println(&quot;请输入上次成绩&quot;);\n        int before &#x3D; scanner.nextInt();\n        double result &#x3D; 100.0*(now-before)&#x2F;before;\n        System.out.printf(&quot;成绩提高了%.2f %%&quot;,result);\n\n通过BufferReader**(输入可以带空格)**\npublic static void main(String args[])&#123;\n\tBufferedReader buf &#x3D; null ;\t\t&#x2F;&#x2F; 声明对象\n\tbuf &#x3D; new BufferedReader(new InputStreamReader(System.in)) ;&#x2F;&#x2F; 将字节流变为字符流\n\tString str &#x3D; null ;\t&#x2F;&#x2F; 接收输入内容\n\tSystem.out.print(&quot;请输入内容：&quot;) ;\n\ttry&#123;\n\t\tstr &#x3D; buf.readLine() ;\t&#x2F;&#x2F; 读取一行数据\n\t&#125;catch(IOException e)&#123;\n\t\te.printStackTrace() ;\t&#x2F;&#x2F; 输出信息\n\t&#125;\n\tSystem.out.println(&quot;输入的内容为：&quot; + str) ;\n\n\n\n\n\n\n\n\n\n","slug":"java1","date":"2021-03-29T05:48:25.000Z","categories_index":"Java","tags_index":"","author_index":"Hubert"}]