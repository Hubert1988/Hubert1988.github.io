{"title":"golang-基础","uid":"7c23f20e9197b6064d9ced0e7cb118d0","slug":"golang","date":"2022-04-26T05:48:25.000Z","updated":"2022-05-05T02:59:16.899Z","comments":true,"path":"api/articles/golang.json","keywords":null,"cover":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xbqdrlg1j31hc0u0q5e.jpg","content":"<h1 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h1><h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>Go语言也称为 Golang，是由 Google 公司开发的一种<strong>静态强类型、编译型、并发型、并具有垃圾回收功能</strong>的编程语言。 </li>\n<li>特点：<ul>\n<li>语法简单</li>\n<li>并发模型<ul>\n<li>Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。</li>\n</ul>\n</li>\n<li>内存分配</li>\n<li>垃圾回收</li>\n<li>静态链接</li>\n<li>标准库</li>\n<li>工具链</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li><p>注意事项：</p>\n<ul>\n<li>关于别名<ul>\n<li>可以理解为一种变量类型取了个别名<ul>\n<li><strong>byte</strong>  alias for <strong>uint8</strong></li>\n<li><strong>rune</strong> alias for  <strong>int32</strong></li>\n</ul>\n</li>\n<li>底层数据结构相等并不意味着就是别名<ul>\n<li>比如不同平台的<strong>int</strong>和<strong>int64</strong>或<strong>int32</strong>还是需要类型转换</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分类标准一</p>\n<ul>\n<li><p>布尔型</p>\n</li>\n<li><p>数值型</p>\n<ul>\n<li><p>整形</p>\n<ul>\n<li>int和uint  <ul>\n<li>它们分别对应特定 CPU 平台的字长（机器字大小），其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化。</li>\n</ul>\n</li>\n<li>无符号 uint8       uint16          uint32    uint64</li>\n<li>​有符号 int8          int16            int32        int64</li>\n</ul>\n</li>\n<li><p>浮点</p>\n<ul>\n<li>float32  大约 6 个十进制数的精度 </li>\n<li>float64   大约 15 个十进制数的精度</li>\n</ul>\n</li>\n<li><p>复数</p>\n<ul>\n<li><p>complex128（64 位实数和虚数） </p>\n</li>\n<li><p>complex64（32 位实数和虚数） </p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var name complex128 &#x3D; complex(x, y)</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>字符串</p>\n</li>\n<li><p>派生类型</p>\n<ul>\n<li>(a) 指针类型（Pointer）</li>\n<li>(b) 数组类型</li>\n<li>(c) 结构体类型(struct)</li>\n<li>(d) Channel 类型</li>\n<li>(e) 函数类型</li>\n<li>(f) 切片类型</li>\n<li>(g) 接口类型（interface）</li>\n<li>(h) Map 类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分类标准二：</p>\n<ul>\n<li>非引用类型：<ul>\n<li>包含int、float、bool、string、struct、数组</li>\n</ul>\n</li>\n<li>引用类型<ul>\n<li>map、slice、channel、interface</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"量\"><a href=\"#量\" class=\"headerlink\" title=\"量\"></a>量</h3><h4 id=\"变量（var）\"><a href=\"#变量（var）\" class=\"headerlink\" title=\"变量（var）\"></a>变量（var）</h4><ul>\n<li><p>变量类型   （Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。）</p>\n<ul>\n<li><p>局部变量</p>\n<ul>\n<li><strong>声明了必须使用，未被声明会报错</strong>，在函数体内定义。</li>\n</ul>\n</li>\n<li><p>全局变量</p>\n<ul>\n<li>声明了可以不用使用，<strong>全局变量声明必须以 var 关键字开头</strong>，如果想要在外部包中使用全局变量的首字母必须大写。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>声明变量</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var xxx， xxx 变量类型\n\nvar vname1, vname2, vname3 &#x3D; v1, v2, v3 &#x2F;&#x2F; 和 python 很像,不需要显示声明类型，自动推断\n\nf :&#x3D; &quot;Runoob&quot;         &#x2F;&#x2F; ！！！这种不带声明格式的只能在函数体中出现\n&#x2F;&#x2F;关于简短模式的注意事项\n&#x2F;&#x2F; 1.简短模式不是简单的赋值，而是一种简短的定义变量和赋值操作\n&#x2F;&#x2F; 2.简短模式在同一个作用域下会退化为赋值操作，不同作用域下为原功能\n\nvar (                &#x2F;&#x2F; 这种因式分解关键字的写法一般用于声明全局变量\n    a int\n    b bool\n)</code></pre>\n</li>\n<li><p>变量初始值</p>\n<ul>\n<li>数值                   0</li>\n<li>布尔                 false</li>\n<li>字符串              “”(空字符串)</li>\n<li>派生类型          nil</li>\n</ul>\n</li>\n<li><p>匿名变量</p>\n<ul>\n<li><strong>“_”</strong> 本身就是一个特殊的标识符，被称为空白标识符。</li>\n<li>空标识符可用来临时规避编译器对未使用变量和导入包的错误检查。但请注意，它是预置成员,不能重新定义。</li>\n</ul>\n</li>\n<li><p>命名注意事项</p>\n<ul>\n<li>符号<strong>名字首字母大小写决定了其作用域</strong>。首字母大写的为导出成员，可被包外引用，而小写则仅能在包内使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"常量（const）\"><a href=\"#常量（const）\" class=\"headerlink\" title=\"常量（const）\"></a>常量（const）</h4><ul>\n<li><p>声明常量</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">const xxxx &#x3D; xxx\nconst xxxx 类型 &#x3D; xxx\nconst （\n    xxx 类型\n    xxx 类型\n）</code></pre>\n</li>\n<li><p>iota</p>\n<ul>\n<li><p>就是每个常量行建立的索引值</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次\nfunc main() &#123;\n    const (\n            a &#x3D; iota   &#x2F;&#x2F;0\n            b          &#x2F;&#x2F;1\n            c          &#x2F;&#x2F;2\n            d &#x3D; &quot;ha&quot;   &#x2F;&#x2F;独立值，iota +&#x3D; 1\n            e          &#x2F;&#x2F;&quot;ha&quot;   iota +&#x3D; 1\n            f &#x3D; 100    &#x2F;&#x2F;iota +&#x3D;1\n            g          &#x2F;&#x2F;100  iota +&#x3D;1\n            h &#x3D; iota   &#x2F;&#x2F;7,恢复计数\n            i          &#x2F;&#x2F;8\n    )\n    fmt.Println(a,b,c,d,e,f,g,h,i)\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"自定义量-（type）\"><a href=\"#自定义量-（type）\" class=\"headerlink\" title=\"自定义量 （type）\"></a>自定义量 （type）</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type 变量名称 变量类型</code></pre>\n\n\n\n\n\n\n\n\n\n<h3 id=\"运算符号\"><a href=\"#运算符号\" class=\"headerlink\" title=\"运算符号\"></a>运算符号</h3><ul>\n<li><p>*和  &amp;  <strong>（理解）</strong></p>\n<p>&amp;：取变量的地址值</p>\n<p>*：取地址值的变量</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main()&#123;\n    var a int &#x3D; 4\n    var ptr int\n    ptr &#x3D; a \n    fmt.Println(ptr)&#x2F;&#x2F;4\n    a &#x3D; 15\n    fmt.Println(ptr)&#x2F;&#x2F;4\n    \n    var b int &#x3D; 5 \n    var ptr1 *int\n    ptr1 &#x3D; &amp;b \n    fmt.Println(*ptr1)&#x2F;&#x2F;5\n    b&#x3D;15 \n    fmt.Println(*ptr1)&#x2F;&#x2F;15\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"流程控制：\"><a href=\"#流程控制：\" class=\"headerlink\" title=\"流程控制：\"></a>流程控制：</h3><h4 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h4><ul>\n<li><p>if</p>\n<ul>\n<li>注意事项：基于重构原则，应该保持代码块的逻辑单一</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if 布尔表达式 &#123;\n   &#x2F;* 在布尔表达式为 true 时执行 *&#x2F;\n&#125; else &#123;\n  &#x2F;* 在布尔表达式为 false 时执行 *&#x2F;\n&#125;\n\n\n&#x2F;&#x2F;if 的表达式前可以添加语句或执行初始化,该语句声明的变量作用域仅在 if 和 else 之内。\nif v :&#x3D; 10; v &gt;9&#123;\n\t\tfmt.Println(v)\n&#125;</code></pre>\n</li>\n<li><p>switch</p>\n<p><strong>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。</strong> </p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n   &#x2F;* 定义局部变量 *&#x2F;\n   var grade string &#x3D; &quot;B&quot;\n   var marks int &#x3D; 90\n\n   switch marks &#123;\n      case 90: grade &#x3D; &quot;A&quot;\n      case 80: grade &#x3D; &quot;B&quot;\n      case 50,60,70 : grade &#x3D; &quot;C&quot;\n      default: grade &#x3D; &quot;D&quot;                 &#x2F;&#x2F;default只有全部没有匹配成功时才会使用\n   &#125;\n\n   switch &#123;\n      case grade &#x3D;&#x3D; &quot;A&quot; :\n         fmt.Printf(&quot;优秀!\\n&quot; )    \n      case grade &#x3D;&#x3D; &quot;B&quot;, grade &#x3D;&#x3D; &quot;C&quot; :\n         fmt.Printf(&quot;良好\\n&quot; )      \n      case grade &#x3D;&#x3D; &quot;D&quot; :\n         fmt.Printf(&quot;及格\\n&quot; )      \n      case grade &#x3D;&#x3D; &quot;F&quot;:\n         fmt.Printf(&quot;不及格\\n&quot; )\n      default:\n         fmt.Printf(&quot;差\\n&quot; );\n   &#125;\n   fmt.Printf(&quot;你的等级是 %s\\n&quot;, grade );      \n&#125;</code></pre></li>\n</ul>\n<h4 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h4><ul>\n<li><p>for语句</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n        sum :&#x3D; 0\n        &#x2F;&#x2F;标准形式\n        for i :&#x3D; 0; i &lt;&#x3D; 10; i++ &#123;\n                sum +&#x3D; i\n        &#125;\n        fmt.Println(sum)\n\n        &#x2F;&#x2F; 这样写也可以，更像 While 语句形式\n        for sum &lt;&#x3D; 10&#123;\n                sum +&#x3D; sum\n        &#125;\n        fmt.Println(sum)\n       &#x2F;&#x2F; 无限循环模式\n        for &#123;\n           \n        &#125;\n    \n    \n&#125;</code></pre>\n\n<ul>\n<li>注意事项<ul>\n<li><strong>初始化语句仅被执行一次</strong>。条件表达式中如有函数调用，须确认是否会重复执行。可能会被编译器优化掉,也可能是动态结果须每次执行确认。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>for range语句</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">for index, value :&#x3D; range xxxx&#123;\n    \n&#125;\n&#x2F;&#x2F;可以遍历索引和值，_可以替代为空</code></pre>\n</li>\n<li><p>关键字</p>\n<ul>\n<li><p>goto（无条件转移行）</p>\n<p>在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 </p>\n</li>\n<li><p>break（结束循环）</p>\n</li>\n<li><p>continue（重新开始循环）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><ul>\n<li><p>defer（延迟执行语句）</p>\n<ul>\n<li><p>理解：类似于java中的finnaly，defer标注的语句会在函数最后执行，如果有多个defer语句，他们之间的顺序是逆序的，类似于栈的先进后出</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n    fmt.Println(&quot;defer begin&quot;)\n    &#x2F;&#x2F; 将defer放入延迟调用栈\n    defer fmt.Println(1)\n    defer fmt.Println(2)\n    &#x2F;&#x2F; 最后一个放入, 位于栈顶, 最先调用\n    defer fmt.Println(3)\n    fmt.Println(&quot;defer end&quot;)\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据类型集合\"><a href=\"#数据类型集合\" class=\"headerlink\" title=\"数据类型集合\"></a>数据类型集合</h3><h5 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h5><ul>\n<li><p>是什么？</p>\n<ul>\n<li>是一种数据结构</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ol>\n<li>元素类型一致</li>\n<li>长度固定</li>\n<li>元素值可以修改</li>\n</ol>\n</li>\n<li><p>使用</p>\n<ol>\n<li><p>定义</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;定义数组\nvar balance [10] float32\n&#x2F;&#x2F;定义并初始化\nvar balance &#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F;定义并初始化时，可以用... 代替长度\nvar balance &#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n或\nbalance :&#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></pre>\n</li>\n<li><p>访问</p>\n<ul>\n<li>通过数组索引进行访问</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>多维数组</p>\n<ul>\n<li><p>初始化</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">a :&#x3D; [3][4]int&#123;  \n &#123;0, 1, 2, 3&#125; ,   &#x2F;*  第一行索引为 0 *&#x2F;\n &#123;4, 5, 6, 7&#125; ,   &#x2F;*  第二行索引为 1 *&#x2F;\n &#123;8, 9, 10, 11&#125;&#125;   &#x2F;* 第三行索引为 2 *&#x2F;</code></pre>\n</li>\n<li><p>访问（通过循环角标）</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;* 输出数组元素 *&#x2F;\n   for  i &#x3D; 0; i &lt; 5; i++ &#123;\n      for j &#x3D; 0; j &lt; 2; j++ &#123;\n         fmt.Printf(&quot;a[%d][%d] &#x3D; %d\\n&quot;, i,j, a[i][j] )\n      &#125;\n   &#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h5><ul>\n<li><p>基本概念</p>\n<ul>\n<li>俗称  “动态数组”，可以简单的理解为长度可以变化的数组</li>\n<li>实际上是一种特殊的<strong>数据结构</strong>，<strong>切片并不存储任何数据，它只是描述了底层数组中的一段。</strong> </li>\n<li>理解：<ul>\n<li>切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片</li>\n</ul>\n</li>\n</ul>\n<p>三要素：</p>\n<ul>\n<li>指针</li>\n<li>长度</li>\n<li>容量</li>\n</ul>\n</li>\n<li><p>创建和初始化切片</p>\n<ul>\n<li><p>通过对已存在的数组进行相关截断</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">list :&#x3D; [...]int&#123;1,2,3,4&#125;\nslice :&#x3D; list[1,3]</code></pre>\n</li>\n<li><h5 id=\"通过字面量创建（本质上和第一种原理相同，只不过是数组的全引用）\"><a href=\"#通过字面量创建（本质上和第一种原理相同，只不过是数组的全引用）\" class=\"headerlink\" title=\"通过字面量创建（本质上和第一种原理相同，只不过是数组的全引用）\"></a>通过字面量创建（本质上和第一种原理相同，只不过是数组的全引用）</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 创建字符串切片\n&#x2F;&#x2F; 其长度和容量都是 3 个元素\nmyStr :&#x3D; []string&#123;&quot;Jack&quot;, &quot;Mark&quot;, &quot;Nick&quot;&#125;\n&#x2F;&#x2F; 创建一个整型切片\n&#x2F;&#x2F; 其长度和容量都是 4 个元素\nmyNum :&#x3D; []int&#123;10, 20, 30, 40&#125;\n var numbers []int</code></pre>\n</li>\n<li><p><strong>通过make方法(一般用于创建切片)</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">slice :&#x3D; make([]int, len,volume)\n&#x2F;&#x2F;容量通常为底层数组的长度</code></pre>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>方法1和2,3最大的区别是<strong>底层数组的对外暴露问题</strong>，方法2,3只能通过slice来编辑底层数组，而方法1可以用原来数组的名来引用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态增长特性</p>\n<ul>\n<li><strong>append在追加时，如果容量不够，则会在底层创建新的数组，所以限制切片赋值时的容量大小（len&#x3D;cap）可以有效的避免该问题</strong>（重难点）</li>\n</ul>\n</li>\n<li><p>相关操作</p>\n<ul>\n<li><p>遍历</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">myNum :&#x3D; []int&#123;10, 20, 30, 40, 50&#125;\n&#x2F;&#x2F; 从第三个元素开始迭代每个元素\nfor index :&#x3D; 2; index &lt; len(myNum); index++ &#123;\n    ...\n&#125;</code></pre>\n</li>\n<li><p>拷贝</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">num1 :&#x3D; []int&#123;10, 20, 30&#125;\nnum2 :&#x3D; make([]int, 5)\ncount :&#x3D; copy(num2, num1)\nfmt.Println(count)\nfmt.Println(num2)\n&#x2F;&#x2F;结果\n\n3\n[10 20 30 0 0]</code></pre>\n</li>\n<li><p>增加</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">slice &#x3D; apppend(slice, new_slice...)</code></pre></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><ul>\n<li><p>是什么</p>\n<ul>\n<li>就是字典，用来存储键值对</li>\n</ul>\n</li>\n<li><p>底层结构</p>\n<ul>\n<li>可以类比java中的map，key是不可重复的</li>\n</ul>\n</li>\n<li><p>初始化</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var mapname map[keytype]valuetype &#x3D; map[keytype]valuetype&#123;key:value, key:value&#125;\n\nmapname :&#x3D; map[keytype]valuetype&#123;key:value, key:value&#125;\n\nmapname :&#x3D; make(map[keytype]valuetype)</code></pre>\n</li>\n<li><p>相关操作</p>\n<ul>\n<li><p>删除</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">delete(k,v)</code></pre>\n</li>\n<li><p>增加和修改</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">map[k]&#x3D;v\n&#x2F;&#x2F;如果k存在，则是修改，如果不存在，则是增加</code></pre></li>\n</ul>\n</li>\n<li><p>切片map</p>\n<ul>\n<li>个人感觉语法很怪，暂时没有深入了解</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><ul>\n<li><p>是什么</p>\n<ul>\n<li>本质上也是一个变量，只不过存储变量的地址值，<strong>一个指针变量指向了一个值的内存地址。</strong></li>\n</ul>\n</li>\n<li><p>基础操作</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n   var a int&#x3D; 20   &#x2F;* 声明实际变量 *&#x2F;\n   var ip *int        &#x2F;* 声明指针变量 *&#x2F;\n\n   ip &#x3D; &amp;a  &#x2F;* 指针变量的存储地址 *&#x2F;\n\n   fmt.Printf(&quot;a 变量的地址是: %x\\n&quot;, &amp;a  )\n\n   &#x2F;* 指针变量的存储地址 *&#x2F;\n   fmt.Printf(&quot;ip 变量储存的指针地址: %x\\n&quot;, ip )\n\n   &#x2F;* 使用指针访问值 *&#x2F;\n   fmt.Printf(&quot;*ip 变量的值: %d\\n&quot;, *ip )</code></pre>\n\n<ul>\n<li>*: 声明为变量指针，为指针变量赋值只能赋地址值</li>\n<li>*加上指针变量用来访问指针变量中指向地址的值。</li>\n</ul>\n</li>\n<li><p>指针数组</p>\n<ul>\n<li>就是用来存放多个地址的数据结构</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n   a :&#x3D; []int&#123;10,100,200&#125;\n   var i int\n   var ptr [MAX]*int;\n\n   for  i &#x3D; 0; i &lt; MAX; i++ &#123;\n      ptr[i] &#x3D; &amp;a[i] &#x2F;* 整数地址赋值给指针数组 *&#x2F;\n   &#125;\n\n   for  i &#x3D; 0; i &lt; MAX; i++ &#123;\n      fmt.Printf(&quot;a[%d] &#x3D; %d\\n&quot;, i,*ptr[i] )\n   &#125;\n&#125;</code></pre>\n\n\n</li>\n<li><p>指针的指针</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var a int\n   var ptr *int\n   var pptr **int\n\n   a &#x3D; 3000\n\n   &#x2F;* 指针 ptr 地址 *&#x2F;\n   ptr &#x3D; &amp;a\n\n   &#x2F;* 指向指针 ptr 地址 *&#x2F;\n   pptr &#x3D; &amp;ptr\n\n   &#x2F;* 获取 pptr 的值 *&#x2F;\n   fmt.Printf(&quot;变量 a &#x3D; %d\\n&quot;, a )\n   fmt.Printf(&quot;指针变量 *ptr &#x3D; %d\\n&quot;, *ptr )\n   fmt.Printf(&quot;指向指针的指针变量 **pptr &#x3D; %d\\n&quot;, **pptr)</code></pre></li>\n</ul>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ul>\n<li><h5 id=\"Go语言里面拥三种类型的函数：\"><a href=\"#Go语言里面拥三种类型的函数：\" class=\"headerlink\" title=\"Go语言里面拥三种类型的函数：\"></a>Go语言里面拥三种类型的函数：</h5><ul>\n<li>普通的带有名字的函数</li>\n<li>匿名函数或者 lambda 函数(<strong>闭包</strong>)</li>\n<li>方法</li>\n</ul>\n</li>\n<li><h5 id=\"普通函数定义和操作\"><a href=\"#普通函数定义和操作\" class=\"headerlink\" title=\"普通函数定义和操作\"></a>普通函数定义和操作</h5></li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;* 函数返回两个数的最大值 *&#x2F;\nfunc max(num1, num2 int) （int） &#123;\n   &#x2F;* 声明局部变量 *&#x2F;\n   var result int\n\n   if (num1 &gt; num2) &#123;\n      result &#x3D; num1\n   &#125; else &#123;\n      result &#x3D; num2\n   &#125;\n   return result\n&#125;</code></pre>\n\n<ul>\n<li><h5 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h5><ul>\n<li><p>定义：匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成 （没有名字的普通函数）</p>\n</li>\n<li><p>特点：</p>\n<ul>\n<li>动态创建（和普通函数最大的区别）,并且可以作为返回值</li>\n</ul>\n</li>\n<li><p>常见操作</p>\n<ul>\n<li><p>在定义时调用匿名函数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func(data int) &#123;\n    fmt.Println(&quot;hello&quot;, data)\n&#125;(100)</code></pre>\n</li>\n<li><p>将匿名函数赋值给变量</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 将匿名函数体保存到f()中\nf :&#x3D; func(data int) &#123;\n    fmt.Println(&quot;hello&quot;, data)\n&#125;\n&#x2F;&#x2F; 使用f()调用\nf(100)</code></pre>\n\n<ul>\n<li><p>匿名函数用作回调函数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 遍历切片的每个元素, 通过给定函数进行元素访问\nfunc visit(list []int, f func(int)) &#123;\n    for _, v :&#x3D; range list &#123;\n        f(v)\n    &#125;\n&#125;\nfunc main() &#123;\n    &#x2F;&#x2F; 使用匿名函数打印切片内容\n    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;\n        fmt.Println(v)\n    &#125;)\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h5 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h5><ul>\n<li><p>概述：</p>\n<ul>\n<li>闭包是函数的一种高级应用</li>\n<li>因为匿名函数是动态创建的，所以可以直接调用外部的变量，而不是像普通函数通过参数传递变量</li>\n</ul>\n</li>\n<li><p>理解：</p>\n<ul>\n<li>为什么叫做闭包。首先可以理解为一个封闭的包，而包的特点就是可以调用包内的变量，匿名函数和它引用的变量以及环境，类似常规函数引用全局变量处于一个包的环境。</li>\n</ul>\n</li>\n<li><p>闭包 &#x3D; 匿名函数 + 当前环境</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n\tn :&#x3D; 0\n\tf :&#x3D; func() int &#123;\n\t\tn +&#x3D; 1\n\t\treturn n\n\t&#125;\n\tfmt.Println(f())  &#x2F;&#x2F; 别忘记括号，不加括号相当于地址\n\tfmt.Println(f())\n&#125;</code></pre>\n</li>\n<li><p>闭包作为返回值</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Increase() func() int &#123;\n\tn :&#x3D; 0\n\treturn func() int &#123;\n\t\tn++\n\t\treturn n\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\tin :&#x3D; Increase()\n\tfmt.Println(in())\n\tfmt.Println(in())\n&#125;\n</code></pre></li>\n</ul>\n</li>\n<li><h5 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h5><ul>\n<li><p>定义</p>\n<ul>\n<li>类比java中的方法，因为go没有对象，而结构体内无法定义方法，所以采用在函数上添加特定结构体接收者的办法创建方法</li>\n<li>总结：            方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</li>\n</ul>\n</li>\n<li><p>注意事项</p>\n<ul>\n<li><p>方法就是个函数，和java中不一样，不要当对象的方法来使用</p>\n</li>\n<li><p><strong>指针接受者</strong>（<strong>接受者的类型前添加*，会指向原对象</strong>，而值接收者只会对副本进行操作）</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;指针接收者\ntype person struct &#123;\n\t name string\n\t age int8\n&#125;\n\nfunc (p *person) setName(name string) &#123;\n\tp.name &#x3D; name\n&#125;\n\nfunc main() &#123;\n\n\tp :&#x3D;person&#123;&quot;hu&quot;,8&#125;\n\tp.setName(&quot;huyu&quot;)\n\tfmt.Println(p.name)\n&#125;\n&#x2F;&#x2F;值接收者\ntype person struct &#123;\n\t name string\n\t age int8\n&#125;\n\nfunc (p person) setName(name string) &#123;\n\tp.name &#x3D; name\n&#125;\n\nfunc main() &#123;\n\n\tp :&#x3D;person&#123;&quot;hu&quot;,8&#125;\n\tp.setName(&quot;huyu&quot;)\n\tfmt.Println(p.name)\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h5 id=\"错误处理（暂时大概了解了下）\"><a href=\"#错误处理（暂时大概了解了下）\" class=\"headerlink\" title=\"错误处理（暂时大概了解了下）\"></a>错误处理（暂时大概了解了下）</h5><ul>\n<li>概述：<ul>\n<li>go中的错误处理就是类似于java中的异常机制，主要是来处理编译时异常的。</li>\n</ul>\n</li>\n<li>背景：<ul>\n<li>Go语言没有类似 <a href=\"http://c.biancheng.net/java/\">Java</a> 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。  Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h5 id=\"宕机（panic）和宕机恢复（recover）\"><a href=\"#宕机（panic）和宕机恢复（recover）\" class=\"headerlink\" title=\"宕机（panic）和宕机恢复（recover）\"></a>宕机（panic）和宕机恢复（recover）</h5></li>\n<li><h5 id=\"函数传参问题\"><a href=\"#函数传参问题\" class=\"headerlink\" title=\"函数传参问题\"></a>函数传参问题</h5><ul>\n<li><p>可变参数</p>\n<ul>\n<li>类比java，就是向函数中传递的参数个数不确定的时候，可以用可变参数进行传参</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func myfunc(args ...int) &#123;\n    for _, arg :&#x3D; range args &#123;\n        fmt.Println(arg)\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>如果不进传递参数的数量不确定，并且类型不确定，可以使用interface类型</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\nimport &quot;fmt&quot;\nfunc MyPrintf(args ...interface&#123;&#125;) &#123;\n    for _, arg :&#x3D; range args &#123;\n        switch arg.(type) &#123;\n            case int:\n                fmt.Println(arg, &quot;is an int value.&quot;)\n            case string:\n                fmt.Println(arg, &quot;is a string value.&quot;)\n            case int64:\n                fmt.Println(arg, &quot;is an int64 value.&quot;)\n            default:\n                fmt.Println(arg, &quot;is an unknown type.&quot;)\n        &#125;\n    &#125;\n&#125;\nfunc main() &#123;\n    var v1 int &#x3D; 1\n    var v2 int64 &#x3D; 234\n    var v3 string &#x3D; &quot;hello&quot;\n    var v4 float32 &#x3D; 1.234\n    MyPrintf(v1, v2, v3, v4)\n&#125;</code></pre>\n</li>\n<li><p>首先说结论：</p>\n<ul>\n<li>在Go语言里，<strong>go 语言中所有东西都是以值进行传递的，没有引用传递</strong> <ul>\n<li>非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；</li>\n<li>有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</li>\n</ul>\n</li>\n<li>非引用类型（值类型）：int，float，bool，string，以及<strong>数组</strong>和<strong>struct</strong><ul>\n<li>特点：变量直接存储值，内存通常在栈中分配，栈在函数调用完会被释放</li>\n</ul>\n</li>\n<li>引用类型：指针，slice，map，chan，接口，函数等<ul>\n<li>特点：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，通过GC回收</li>\n</ul>\n</li>\n</ul>\n<p><strong>其中 指针可以作为中间的桥梁，获得非引用类型数据的地址，从未能够修改原地址，在结构体类型中常用</strong></p>\n</li>\n</ul>\n</li>\n<li><p>注意事项</p>\n<ol>\n<li><p><strong><a href=\"https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020\">编译器</a>在编译时不会管if、else if等语句内的return语句，不知道你具体会在哪里返回，这个只有程序运行时才能确定。所以，如果你程序最后没有return语句，编译器就认为你错了，语法不通过。</strong> </p>\n</li>\n<li><p>函数可以返回多个值</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func swap(x, y string) (string, string) &#123;\n   return y, x\n&#125;</code></pre>\n</li>\n<li><p>函数可以作为返回值（本质上函数也可以作为变量，叫<strong>函数变量</strong>）</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func test(x int)func() &#123;        &#x2F;&#x2F; 返回函数类型 \n   return func() &#123;          &#x2F;&#x2F; 匿名函数 \n       println(x)            &#x2F;&#x2F; 闭包 \n    &#125; \n&#125; \nfunc main() &#123; \n   x:&#x3D;100\n  \n   f:&#x3D;test(x) \n   f() \n&#125;</code></pre></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"面对对象\"><a href=\"#面对对象\" class=\"headerlink\" title=\"面对对象\"></a>面对对象</h3><h5 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h5><ul>\n<li><p>是什么</p>\n<ul>\n<li>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 （<strong>就是类似于java中的一个类</strong>）</li>\n</ul>\n</li>\n<li><p>如何使用</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n   var Book1 Books        &#x2F;* 声明 Book1 为 Books 类型 *&#x2F;\n   var Book2 Books        &#x2F;* 声明 Book2 为 Books 类型 *&#x2F;\n\n   &#x2F;* book 1 描述 *&#x2F;\n   Book1.title &#x3D; &quot;Go 语言&quot;\n   Book1.author &#x3D; &quot;www.runoob.com&quot;\n   Book1.subject &#x3D; &quot;Go 语言教程&quot;\n   Book1.book_id &#x3D; 6495407\n\n   &#x2F;* book 2 描述 *&#x2F;\n   Book2.title &#x3D; &quot;Python 教程&quot;\n   Book2.author &#x3D; &quot;www.runoob.com&quot;\n   Book2.subject &#x3D; &quot;Python 语言教程&quot;\n   Book2.book_id &#x3D; 6495700\n\n   &#x2F;* 打印 Book1 信息 *&#x2F;\n   printBook(Book1)\n\n   &#x2F;* 打印 Book2 信息 *&#x2F;\n   printBook(Book2)\n&#125;\n\nfunc printBook( book Books ) &#123;\n   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)\n   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)\n   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)\n   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)\n&#125;</code></pre>\n</li>\n<li><p>结构体指针</p>\n<ul>\n<li><strong>结构体指针可以隐形的使用</strong></li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。\nfunc main() &#123;\n\tv :&#x3D; Vertex&#123;1, 2&#125;\n\tp :&#x3D; &amp;v\n\tp.X &#x3D; 1e9\n\tfmt.Println(v)\n&#125;</code></pre></li>\n</ul>\n<h5 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h5><ul>\n<li>具体使用可以看函数中的方法使用</li>\n<li>理解：<ul>\n<li>类比java中的方法，因为java类中可以主动定义方法，但是go只有结构体，所以结构体只能定义类似于java类中的属性，要想定义方法，只能利用类似于“<strong>外部挂载的方式</strong>”，声明一个函数属于哪个结构体的方式实现java中类的方法实现</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h5><ul>\n<li>是什么<ul>\n<li>类比java，一个接口是一组方法集合</li>\n<li>如果一个类型包含了一个接口声明的所有方法，那么这个类型就<strong>隐式地实现</strong>了这个接口。 <ul>\n<li>如何理解为隐式实现<ul>\n<li>只要实现接口内的全部方法即可，而和接口名称没有任何关系，是基于方法的实现，和传统的OOP接口实现不同，耦合性很小</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>理解<ul>\n<li>golang中的接口是golang实现多态的方式，而java是基于继承的方式，我们可以类比java，golang中的接口就是java中的父类，而实现接口的结构体相当于子类，最终的结果就是父类中的引用指向子类的对象（接口的引用指向实现接口的结构体）</li>\n<li>无论是java中的继承还是golang中的接口，多态的实现的本质都是方法的重写</li>\n</ul>\n</li>\n<li>应用场景<ol>\n<li>类似于usb的例子，电脑有usb接口，如果其他外设想要连接电脑，只要实现usb即可</li>\n<li>在开发中，可以利用接口定义好方法，然后分层来实现，用于开发流程</li>\n</ol>\n</li>\n<li>注意事项<ol>\n<li>接口本身不可以实例化，但是可以指向实现了接口的结构体变量</li>\n<li>不仅仅是结构体可以实现接口，任何自定义变量都可以实现接口</li>\n<li>接口之间也可以使用继承来增加复用性</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"三大特性\"><a href=\"#三大特性\" class=\"headerlink\" title=\"三大特性\"></a>三大特性</h5><ul>\n<li><p>封装</p>\n<ul>\n<li>没有java那么明显，仅仅是首字母大小写来规定包内和包外的限制</li>\n</ul>\n</li>\n<li><p>继承</p>\n<ul>\n<li>本质上就是代码复用，而golang是通过匿名结构体嵌套实现</li>\n</ul>\n</li>\n<li><p>多态（向上转型）</p>\n<ul>\n<li><p>具有多种状态</p>\n<ul>\n<li>思想和java差不多，基本都是啥接口变量可以指向实现响应接口的结构体</li>\n</ul>\n</li>\n<li><p>类型断言（向下转型）</p>\n<ul>\n<li><p>背景：</p>\n<ul>\n<li><p>利用多态调用方法时，只能调用接口声明的方法，但是要想执行具体结构体特殊的方法（实际上就是java中的向下转型，将父类转为子类，从而可以使用子类的特殊方法）就得用到类型断言</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">a是接口变量\nb是结构体变量\nb &#x3D; a.（结构体类型）</code></pre></li>\n</ul>\n</li>\n<li><p>转换错误处理</p>\n<ul>\n<li><p>因为接口变量转型得是原来的数据类型，所以为了防止panic，使用标志位进行接收判断</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">a, flag &#x3D; b.(int8)\nif(flag &#x3D;&#x3D; true)&#123;    &#x2F;&#x2F;转换成功\n    \n&#125;else&#123;              &#x2F;&#x2F;转换失败\n    \n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","text":"Golang基础语法概述 Go语言也称为 Golang，是由 Google 公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。 特点： 语法简单 并发模型 Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 go...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"Golang","slug":"Golang","count":1,"path":"api/categories/Golang.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Golang\"><span class=\"toc-text\">Golang</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">基础语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8F\"><span class=\"toc-text\">量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%EF%BC%88var%EF%BC%89\"><span class=\"toc-text\">变量（var）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F%EF%BC%88const%EF%BC%89\"><span class=\"toc-text\">常量（const）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%87%8F-%EF%BC%88type%EF%BC%89\"><span class=\"toc-text\">自定义量 （type）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">运算符号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9A\"><span class=\"toc-text\">流程控制：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">条件语句</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">循环语句</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">关键字</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%9B%86%E5%90%88\"><span class=\"toc-text\">数据类型集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87\"><span class=\"toc-text\">切片</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%EF%BC%88%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%92%8C%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%8E%9F%E7%90%86%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%A8%E5%BC%95%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">通过字面量创建（本质上和第一种原理相同，只不过是数组的全引用）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Go%E8%AF%AD%E8%A8%80%E9%87%8C%E9%9D%A2%E6%8B%A5%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">Go语言里面拥三种类型的函数：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">普通函数定义和操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">匿名函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%88%E6%9A%82%E6%97%B6%E5%A4%A7%E6%A6%82%E4%BA%86%E8%A7%A3%E4%BA%86%E4%B8%8B%EF%BC%89\"><span class=\"toc-text\">错误处理（暂时大概了解了下）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%95%E6%9C%BA%EF%BC%88panic%EF%BC%89%E5%92%8C%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%EF%BC%88recover%EF%BC%89\"><span class=\"toc-text\">宕机（panic）和宕机恢复（recover）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">函数传参问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面对对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">三大特性</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Hubert","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Start","uid":"e38905ad1968dd93d6be591395b50e19","slug":"strat","date":"3333-03-27T05:48:25.000Z","updated":"2022-05-05T04:14:16.580Z","comments":true,"path":"api/articles/strat.json","keywords":null,"cover":"https://wx4.sinaimg.cn/mw1024/008srJVCly1h1xbzufkgaj31kw0u0dk2.jpg","text":"谨以此站记录本人知识积累-stay hungry stay foolish","link":"","photos":[],"count_time":{"symbolsCount":44,"symbolsTime":"1 mins."},"categories":[{"name":"Begin","slug":"Begin","count":1,"path":"api/categories/Begin.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"K8s","uid":"8b277fff122412f48b0619581df54238","slug":"K8s","date":"2021-08-26T10:49:36.000Z","updated":"2022-05-05T02:30:21.678Z","comments":true,"path":"api/articles/K8s.json","keywords":null,"cover":"https://pic4.zhimg.com/v2-562267b2cf39fded4c66640ac37ee818_1440w.jpg?source=172ae18b","text":"K8s概述前置知识 容器的本质是一种特殊的进程 容器的隔离和资源限制实现 namespace 相当于一个障眼法，利用linux的namespace机制实现隔离，而一个个docker实际上是一个个特殊的进程 Namespace 技术实际上修改了应用进程看待整个计算机“视 图”，即它...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"K8s","slug":"K8s","count":1,"path":"api/categories/K8s.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}