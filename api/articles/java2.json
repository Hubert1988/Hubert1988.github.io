{"title":"Java-面对对象","uid":"a64196a02ebbcb9126814b321ce99582","slug":"java2","date":"2021-04-11T05:48:25.000Z","updated":"2022-05-05T02:59:38.825Z","comments":true,"path":"api/articles/java2.json","keywords":null,"cover":"https://wx1.sinaimg.cn/mw1024/008srJVCly1h1xbqioae2j31gi0u0god.jpg","content":"<h2 id=\"面对对象\"><a href=\"#面对对象\" class=\"headerlink\" title=\"面对对象\"></a>面对对象</h2><h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><ul>\n<li><p>方法</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><p>方法的参数传递问题</p>\n<ul>\n<li>传递基本数据类型和引用数据类型的区别</li>\n<li>传递可变参数</li>\n</ul>\n</li>\n<li><p>方法的重载</p>\n<p>就是相同的方法中，只有参数不同，从而匹配不同的同名方法。</p>\n</li>\n</ol></blockquote>\n</li>\n<li><p>构造方法（构造器）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>注意会默认调用父类的构造器，所以子类在实例化的时候要注意</li>\n</ul></blockquote>\n</li>\n</ul>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><ul>\n<li><p>理解：因为类可以被继承，并且子类可以对父类的方法进行重写，由此可以演进出以父类为模板的，子类来实现的模式，而抽象类可以作为模板</p>\n</li>\n<li><p><strong>抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力</strong>。 </p>\n</li>\n<li><p>注意事项：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><p>抽象类和抽象类的方法用abstract修饰,抽象方法没有代码体</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">abstract class Person &#123;\n    public abstract void run();\n&#125;</code></pre>\n</li>\n<li><p>继承的子类必须重写抽象类的所有方法</p>\n</li>\n<li><p>有抽象方法的类必须是抽象类，抽象类的方法不一定是抽象方法</p>\n</li>\n</ol></blockquote>\n</li>\n</ul>\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><ul>\n<li><p>本质：比抽象类还要抽象的纯抽象接口 ，<strong>一个抽象类没有字段，所有方法全部都是抽象方法的抽象类</strong></p>\n</li>\n<li><p>default方法？  <strong>接口新增方法，无需重写全部子类</strong></p>\n</li>\n<li><p>接口内部除了方法，还可以存在静态变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person &#123;\n    public static final int MALE &#x3D; 1;\n    public static final int FEMALE &#x3D; 2;\n&#125;\n但可以被简写\npublic interface Person &#123;\n    &#x2F;&#x2F; 编译器会自动加上public statc final:\n    int MALE &#x3D; 1;\n    int FEMALE &#x3D; 2;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h4><ul>\n<li>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</li>\n</ul>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><ul>\n<li>通过private将变量隐藏，再通过方法进行操作</li>\n</ul>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><ul>\n<li><p>使用extends关键字进行类的继承</p>\n</li>\n<li><p>super关键字</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>子类构造器第一行有默认super（）调用父类的构造器，所以继承时，子类的构造器要注意super参数的传递问题</p></blockquote>\n</li>\n<li><p><strong>向上转型和向下转型</strong></p>\n<p>向上转型：父类类型的变量指向子类的实例，是安全的</p>\n<p>向下转型：实际上是强制类型转换，不安全，需要进行instanceof进行判断后才行，否则报ClassCastException 错误</p>\n</li>\n<li><p><strong>方法的重写</strong></p>\n<p>就是子类中重新编辑父类中的某个方法，子父类中的方法要严格相同，不相同就是重载</p>\n</li>\n</ul>\n<h4 id=\"多态：\"><a href=\"#多态：\" class=\"headerlink\" title=\"多态：\"></a>多态：</h4><ul>\n<li><p>多态体现为<strong>父类引用变量指向子类对象</strong>。</p>\n<p><strong>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</strong> </p>\n</li>\n<li><p><strong>多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</strong></p>\n</li>\n</ul>\n","text":"面对对象类 方法 方法的参数传递问题 传递基本数据类型和引用数据类型的区别 传递可变参数 方法的重载 就是相同的方法中，只有参数不同，从而匹配不同的同名方法。 构造方法（构造器） 注意会默认调用父类的构造器，所以子类在实例化的时候要注意 抽象类 理解：因为类可以被继承，并且子类可...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Java","slug":"Java","count":5,"path":"api/categories/Java.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面对对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%85\"><span class=\"toc-text\">包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">封装</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%EF%BC%9A\"><span class=\"toc-text\">多态：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hubert","slug":"blog-author","avatar":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xcbhhiq5j309y0dj3z9.jpg","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Net-技术拓展","uid":"0d5b4ab158060e81e0a6127529557325","slug":"net2","date":"2021-04-26T05:48:25.000Z","updated":"2022-05-05T03:02:03.454Z","comments":true,"path":"api/articles/net2.json","keywords":null,"cover":"https://wx2.sinaimg.cn/thumb300/008srJVCly1h1xbqv4c4hj30rs0dwdid.jpg","text":"CGN 定义： 翻译为运营商级地址转换（运营商级NAT），又称作LSN（Large-scale NAT，大规模网络地址转换），是一种基于NAT的更高级应用技术。 个人理解： 就是使用了两次的nat地址转换 地址分配 除了分配的三类私网ip地址，还专门为CGN预留了一个 “共享地址...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Net","slug":"Net","count":4,"path":"api/categories/Net.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xcbhhiq5j309y0dj3z9.jpg","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Net-网络基础","uid":"a293d787cf7979f11b343b04086d0db9","slug":"net3","date":"2021-04-10T05:48:25.000Z","updated":"2022-05-05T02:42:36.023Z","comments":true,"path":"api/articles/net3.json","keywords":null,"cover":"https://wx2.sinaimg.cn/thumb300/008srJVCly1h1xbqv4c4hj30rs0dwdid.jpg","text":"TCP&#x2F;IP体系知识应用层 实际上是和应用打交道，是对相互通信进程之间交换的信息的一种规范 应用层协议：就是规定了交换信息的格式 具体协议 HTTP协议 用于web的一种协议 请求格式 响应格式 HTTPS HTTP+TLS TLS加密方式： 对称加密 ：收发同时使用公...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Net","slug":"Net","count":4,"path":"api/categories/Net.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xcbhhiq5j309y0dj3z9.jpg","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}