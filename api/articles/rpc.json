{"title":"浅析RPC框架","uid":"6baa7e0b0cfe666ab7d296eb78705886","slug":"rpc","date":"2022-05-12T05:48:25.000Z","updated":"2022-05-12T08:34:01.600Z","comments":true,"path":"api/articles/rpc.json","keywords":null,"cover":"https://pic4.zhimg.com/v2-45d69c22c7149dcf15fc4f6320d400f3_r.jpg","content":"<h2 id=\"RPC框架\"><a href=\"#RPC框架\" class=\"headerlink\" title=\"RPC框架\"></a>RPC框架</h2><h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><ul>\n<li>背景<ul>\n<li>IPC（进程间的通信）可以有多种方式，比如本地调用，或者通过网络实现远程调用，而rpc就是在微服务的背景下实现的一种通过网络远程服务调用的一种协议。</li>\n</ul>\n</li>\n<li>概念<ul>\n<li>RPC（远程过程调用，简单的理解是一个节点请求另一个节点提供的服务 ）</li>\n</ul>\n</li>\n<li>本地过程调用和远程调用<ul>\n<li>本地过程调用：<ul>\n<li>如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。</li>\n</ul>\n</li>\n<li>远程过程调用：<ul>\n<li>上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？<ol>\n<li>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</li>\n<li>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</li>\n<li>数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"理解核心思想\"><a href=\"#理解核心思想\" class=\"headerlink\" title=\"理解核心思想\"></a>理解核心思想</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>​       RPC全称为远程过程调用，通过先前的基础概念了解后，也大概理解了什么是远程过程调用，但是为什么我们要用RPC ？使用RPC有什么好处吗？接下来我们从我们平常接触的HTTP协议进行讲解</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>​         大家平常生活中接触最多的协议大概是HTTP协议，而就协议本身来说，实际规定了应用层数据的一个规范，而从使用效果来说，使用HTTP协议实现了客户端到服务器端的一个进程之间，端到端之间的连接（本文的HTTP协议均指的实现了进程之间连接的协议簇，不是应用层定义的规范），仿佛从效果来说HTTP协议视就已经能够基础的完成RPC的远程过程调用的功能，一个进程通过HTTP协议来远程调用另一个进程的相关函数。确实HTTP达到了目的，但却仅仅是完成达到了目的，就好比你的目标是考试不挂科，但你用了“HTTP”，只能考60分，而用“RPC”后，你可以考到90分。甚至RPC能让你有附加分，完成不仅仅是远程过程调用者一个功能。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>​        而这之间的差距就得从框架的核心思想讲起，简单的来说，框架本质是对标准库或者现有基础工具的二次开发，相当于框架是个功能更加强大和智能的“ 标准库”。而HTTP就可以理解为标准库，而RPC框架就是“智能”的标准库</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>​        如果我用基础工具（比如HTTP协议）实现远程过程调用，实现进程间的通信，如果这个两个应用程序位于不同的机器，那么一般会选择 TCP 协议或者 HTTP 协议；那如果两个应用程序位于相同的机器，也可以选择 Unix Socket 协议。传输协议确定之后，还需要确定报文的编码格式，比如采用最常用的 JSON 或者 XML，那如果报文比较大，还可能会选择 protobuf 等其他的编码方式，甚至编码之后，再进行压缩。接收端获取报文则需要相反的过程，先解压再解码。解决了传输协议和报文编码的问题，接下来还需要解决一系列的可用性问题，例如，连接超时了怎么办？是否支持异步请求和并发？之所以这么繁杂，本质原因就是他们的角色定位决定了他们的用途，HTTP这种基础类的工具最大的特点就是具有通用性，就像HTTP可以实现任何端到端的连接，而正是通用性使其不可能完美的在某个方面能力突出。</p></blockquote>\n<p>​         <strong>所以为了解决这些繁琐的问题，rpc框架作为一个工具，提供了这部分公共能力，让开发者无需关心内部细节，而这也恰好印证了框架的核心思想，从通用性强的基础工具进行相关开发，得到专业性强的客制化工具</strong></p>\n<p><img src=\"https://tse2-mm.cn.bing.net/th/id/OIP-C.JjeWRSnDHyB3pphEKJ5E9QHaEL?pid=ImgDet&rs=1\"></p>\n<p>​          我们通过HTTP再到PRC框架，理解了RPC框架能够解决相关问题的痛点后似乎能开始明白了我们为什么要用rpc框架，但我们仅仅<strong>狭义的从远程过程调用</strong>来理解为什么要用RPC框架，为了更加深刻的理解，我们得结合当前的环境来加深理解</p>\n<p><img src=\"https://tse1-mm.cn.bing.net/th/id/R-C.b64d59b56178b0dfeeb52c86e9f8c678?rik=6WA85Wm6sGvqHw&riu=http://www.uml.org.cn/wfw/images/2019030728.png&ehk=unGWlpufdbRDUdtzW3izFmp2Z9eK5GCeHY4iobvdnQQ=&risl=&pid=ImgRaw&r=0\"></p>\n<p>​          随着微服务时代的到来，一个项目的服务被拆分独立部署，那服务间的调用就必然需要网络通信 ，我们想即使服务被拆分了但是使用起来还是和之前本地调用一样方便。这也是 RPC 框架出现的原因，用PRC框架来屏蔽这些底层调用细节，使得我们编码上还是和之前本地调用相差不多。RPC框架就像一个无形的网，连接微服务之间通信调用，使开发者仿佛在开发单体架构般，方便的调用“本地服务”。而我们也渐渐体会到了<strong>我们使用RPC框架</strong>，<strong>构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性</strong> </p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>本文首先从狭义的远程过程调用这个功能的实现上阐述了我们为什么要用RPC框架实现功能，而不是HTTP协议簇来实现，<strong>其实问题的核心就是我们为什么不用标准库或者基本组件开发，而使用框架开发，</strong>而答案就是实通用性工具到客制化工具一种转变思想的体现，最后我们从微服务架构，应用的层面也阐述了我们为什么要用RPC框架来进行开发。</li>\n<li>通过本文对RPC框架的介绍，我们不仅仅了解了RPC框架的特点，也透过RPC框架，对框架和基础工具之间的关系也有了更加深刻的了解，而这也是我初学框架的一点点心得，希望对大家有用。</li>\n</ul>\n","text":"RPC框架基础概念 背景 IPC（进程间的通信）可以有多种方式，比如本地调用，或者通过网络实现远程调用，而rpc就是在微服务的背景下实现的一种通过网络远程服务调用的一种协议。 概念 RPC（远程过程调用，简单的理解是一个节点请求另一个节点提供的服务 ） 本地过程调用和远程调用 本...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Frame","slug":"Frame","count":1,"path":"api/categories/Frame.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RPC%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">RPC框架</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基础概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">理解核心思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"Hubert","slug":"blog-author","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP-C.HOHe3l1T_0UEexBraXs53wAAAA?w=169&h=176&c=7&r=0&o=5&dpr=1.38&pid=1.7","link":"/","description":"<h5>This is my own blog to     share my knowledge</h5>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Start","uid":"e38905ad1968dd93d6be591395b50e19","slug":"strat","date":"3333-03-27T05:48:25.000Z","updated":"2022-05-05T10:41:00.147Z","comments":true,"path":"api/articles/strat.json","keywords":null,"cover":"https://scpic.chinaz.net/files/pic/pic9/201803/wpic078.jpg","text":"谨以此站记录本人知识积累——Stay hungry Stay foolish","link":"","photos":[],"count_time":{"symbolsCount":45,"symbolsTime":"1 mins."},"categories":[{"name":"Begin","slug":"Begin","count":1,"path":"api/categories/Begin.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP-C.HOHe3l1T_0UEexBraXs53wAAAA?w=169&h=176&c=7&r=0&o=5&dpr=1.38&pid=1.7","link":"/","description":"<h5>This is my own blog to     share my knowledge</h5>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"golang-基础","uid":"7c23f20e9197b6064d9ced0e7cb118d0","slug":"golang","date":"2022-04-26T05:48:25.000Z","updated":"2022-05-05T05:42:53.690Z","comments":true,"path":"api/articles/golang.json","keywords":null,"cover":"https://tse3-mm.cn.bing.net/th/id/OIP-C.pRx-ilihnVX98A3VQGqgPgHaEK?w=314&h=180&c=7&r=0&o=5&dpr=1.1&pid=1.7","text":"Golang基础语法概述 Go语言也称为 Golang，是由 Google 公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。 特点： 语法简单 并发模型 Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 go...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"Golang","slug":"Golang","count":1,"path":"api/categories/Golang.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP-C.HOHe3l1T_0UEexBraXs53wAAAA?w=169&h=176&c=7&r=0&o=5&dpr=1.38&pid=1.7","link":"/","description":"<h5>This is my own blog to     share my knowledge</h5>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}