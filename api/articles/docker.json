{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"docker","date":"2021-05-16T05:48:25.000Z","updated":"2022-05-05T02:59:05.789Z","comments":true,"path":"api/articles/docker.json","keywords":null,"cover":"https://wx4.sinaimg.cn/mw1024/008srJVCly1h1xbq920sfj31hc0u0407.jpg","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><p>是什么</p>\n<p>是一款容器引擎，是一个用于开发，交付和运行应用程序的开放平台 </p>\n</li>\n<li><p>作用</p>\n<p>Docker 可以让开发者<strong>打包他们的应用以及依赖包到一个轻量级、可移植的容器中</strong>，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 </p>\n<p>（应用和相关依赖环境一起打包到容器当中）<strong>解决环境依赖，提高开发效率</strong></p>\n</li>\n<li><p>三要素</p>\n<ol>\n<li><p>镜像（花卷）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><p>是什么？</p>\n<ul>\n<li>是一个软件包，该包打包好运行环境，是创造容器的一个模板。是rootfs</li>\n</ul>\n</li>\n<li><p>特性：</p>\n<ul>\n<li><strong>强一致性</strong><ul>\n<li>因为镜像包含了rootfs，而rootfs是包含了操作系统的文件和目录，所以docker容器从底层文件解决了环境的依赖，从而达到一次构建，到处运行的目的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li>镜像层只能可读</li>\n</ul>\n</li>\n<li><p>原理</p>\n<ul>\n<li>UnionFS（联合文件系统），Docker的镜像底层基础是联合文件系统，改系统的特点是支持多层的叠加文件系统，就像花卷一样，Docker可以利用该特点<strong>（分层技术）</strong>来进行创建特定的镜像</li>\n</ul>\n</li>\n<li><p>镜像采用分层技术的优点</p>\n<ul>\n<li>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。 </li>\n<li>功能可扩展性</li>\n</ul>\n</li>\n<li><p>镜像和容器的关系</p>\n<ul>\n<li>类比java，镜像是类，容器是实例</li>\n<li><strong>镜像只能可读，但是容器可操作，而镜像到容器的这个“实例化”的过程是在镜像层上添加容器层</strong></li>\n</ul>\n</li>\n<li><p>虚悬镜像（dangling images）</p>\n<ul>\n<li><p>就是仓库名和tag标签为空的镜像</p>\n</li>\n<li><p>相关操作</p>\n<ul>\n<li><p>查看虚悬镜像</p>\n<p>docker image ls -f dangling&#x3D;true</p>\n</li>\n<li><p>删除虚悬镜像</p>\n<p>docker image prune</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul></blockquote>\n</li>\n<li><p>容器</p>\n<ul>\n<li>本质是一个进程</li>\n</ul>\n</li>\n<li><p>仓库</p>\n<ul>\n<li>存放镜像的地方</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">+-----+-----+-----+-----+                                   +-----+-----+-----+-----+\n|App A|App B|App C|App D|     +-----+-----+-----+-----+     |App A|App B|App C|App D|\n+-----+-----+-----+-----+     |App A|App B|App C|App D|     +-----+-----+-----+-----+\n|+---------------------+|     +-----+-----+-----+-----+     |Guest|Guest|Guest|Guest|\n||   Runtime Library   ||     |Lib A|Lib B|Lib C|Lib D|     | OS0 | OS1 | OS2 | OS3 |\n|+---------------------+|     +-----+-----+-----+-----+     +-----+-----+-----+-----+\n||       Kernel        ||     |    Container Engine   |     |        Hypervisor     |\n|+---------------------+|     +-----------------------+     +-----------------------+\n|   Operating System    |     |         Host OS       |     |         Host OS       |\n+-----------------------+     +-----------------------+     +-----------------------+\n|       Hardware        |     |        Hardware       |     |        Hardware       |\n+-----------------------+     +-----------------------+     +-----------------------+\n    Physical Machine                  Container                 Type II Hypervisor</code></pre>\n</li>\n<li><p>数据卷</p>\n<ul>\n<li><p>是什么？</p>\n<ul>\n<li>是一个存储文件，存储docker容器产生的数据</li>\n<li><a href=\"https://so.csdn.net/so/search?q=Docker&spm=1001.2101.3001.7020\">Docker</a>将运用与运行的环境打包形成容器运行， Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来， 那么当容器删除后，数据自然也就没有了。 为了能保存数据在Docker中我们使用卷。</li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li><strong>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</strong></li>\n</ul>\n</li>\n<li><p>特点</p>\n<ol>\n<li>数据卷可在容器之间共享或重用数据</li>\n<li>卷中的更改可以直接生效</li>\n<li>数据卷中的更改不会包含在镜像的更新中</li>\n<li>数据卷的生命周期一直持续到没有容器使用它为止</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浅析原理\"><a href=\"#浅析原理\" class=\"headerlink\" title=\"浅析原理\"></a>浅析原理</h2><ul>\n<li><strong>容器的本质是一种特殊的进程</strong> </li>\n<li><strong>容器本身没有价值，有价值的是“容器编排</strong> ，容器本身是一个底层技术，解决了应用打包这个问题，但是技术要落地到应用，要落地到Pass平台，所以如何利用容器进行商业化的应用才是真正的价值。</li>\n<li>容器的<strong>隔离</strong>和<strong>资源限制</strong>实现<ol>\n<li>namespace<ul>\n<li>理解：<ul>\n<li>相当于一个障眼法，利用linux的namespace机制实现隔离，而一个个docker实际上是一个个特殊的进程</li>\n<li><strong>Namespace 技术实际上修改了应用进程看待整个计算机“视 图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。但对于宿主机来 说，这些被“隔离”了的进程跟其他进程并没有太大区别。</strong></li>\n</ul>\n</li>\n<li>分类<ul>\n<li>namespace的实现有很多类，比如PID，mount，network等方式（但是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的 改变，一定是伴随着挂载操作（mount）才能生效。 ）</li>\n</ul>\n</li>\n<li>namespace的位置<ul>\n<li>尽管改变了进程的视图，但是在OS上确是实际存在，在namespace就映射在 &#x2F;proc&#x2F;PID&#x2F;ns中，在该文件夹中存储了容器namespace所有的映射，<strong>而这也是docker excec能进入一个容器的原因</strong>（本质上是一个进程加入另一个进程，而进入docker这进程实际上是加入docker的namespace）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>cgroups<ul>\n<li>概念<ul>\n<li>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够 使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</li>\n</ul>\n</li>\n<li>实现资源限制原理：<ul>\n<li><strong>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织 在操作系统的 &#x2F;sys&#x2F;fs&#x2F;cgroup 路径下</strong> </li>\n<li>在 &#x2F;sys&#x2F;fs&#x2F;cgroup目录下又很多资源，比如CPU，内存，如果我们在对应文件里面创建一个进程对应的文件，文件会自动创建一些目录，对响应的目录进行设置即可对资源进行限制，最后在将进程的PID写入task文件即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>容器的安全问题<ul>\n<li>在生产环境中，没有人敢把运行在物理机上的 Linux 容器直接暴露到公网上。因为本质来讲就是一个进程，公用同一个内核，所以安全性不高。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"容器操作\"><a href=\"#容器操作\" class=\"headerlink\" title=\"容器操作\"></a>容器操作</h3><ul>\n<li><p>docker run   创建并运行容器</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker run -it ubuntu &#x2F;bin&#x2F;bash\n-i: 交互式操作。\n-t: 终端。\nubuntu: ubuntu 镜像。\n&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。\n\n\n$ docker run -itd --name ubuntu-test ubuntu &#x2F;bin&#x2F;bash\n在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。\n\n\n\n--name  创建名称\n-d 后台运行\n-P 自动端口映射\n-p 指定端口映射 （默认为tcp）                -p 127.0.0.1：5000:5000\nrunoob@runoob:~$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py  （绑定UDP）</code></pre></blockquote>\n</li>\n<li><p>docker stop   停止容器</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker stop &lt;容器 ID&gt;</code></pre></blockquote>\n</li>\n<li><p>docker start   运行容器</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker start  &lt;容器 ID&gt;</code></pre></blockquote>\n</li>\n<li><p>docker ps       查看当前容器</p>\n</li>\n<li><p>docker exec  进入当前容器</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre class=\"line-numbers language-none\"><code class=\"language-none\">docker exec -it &lt;容器 ID&gt;  &#x2F;bin&#x2F;bash</code></pre></blockquote>\n<ul>\n<li>相关信息总结<ul>\n<li><strong>CONTAINER ID:</strong> 容器 ID。</li>\n<li><strong>IMAGE:</strong> 使用的镜像。</li>\n<li><strong>COMMAND:</strong> 启动容器时运行的命令。</li>\n<li><strong>CREATED:</strong> 容器的创建时间。</li>\n<li><strong>STATUS:</strong> 容器状态。<ul>\n<li>状态有7种：<ul>\n<li>created（已创建）</li>\n<li>restarting（重启中）</li>\n<li>running 或 Up（运行中）</li>\n<li>removing（迁移中）</li>\n<li>paused（暂停）</li>\n<li>exited（停止）</li>\n<li>dead（死亡）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\\udp）。</li>\n<li><strong>NAMES:</strong> 自动分配的容器名称。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>docker export    导出容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker export 1e560fca3906 &gt; ubuntu.tar</code></pre>\n</li>\n<li><p>docker import  导入容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n</li>\n<li><p>dockert rm   删除容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker rm -f 1e560fca3906\n\n下面的命令可以清理掉所有处于终止状态的容器。\n$ docker container prune</code></pre>\n</li>\n<li><p>docker port   查看容器端口映射</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&gt; &gt; &gt; &gt; &gt; &gt; runoob@runoob:~$ docker port bf08b7f2cd89\n&gt; &gt; &gt; &gt; &gt; &gt; 5000&#x2F;tcp -&gt; 0.0.0.0:5000</code></pre>\n</li>\n<li><p>docker log  查看容器日志</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">runoob@runoob:~$ docker logs -f bf08b7f2cd89</code></pre>\n</li>\n<li><p>容器互联</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><p>创建互联网络</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker network create -d bridge test-net</code></pre>\n</li>\n<li><p>将容器添加到互联网络</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker run -itd --name test1 --network test-net ubuntu &#x2F;bin&#x2F;bash</code></pre></li>\n</ol></blockquote>\n</li>\n</ul>\n<h3 id=\"镜像操作\"><a href=\"#镜像操作\" class=\"headerlink\" title=\"镜像操作\"></a>镜像操作</h3><ul>\n<li><p>docker images     </p>\n<p>查看本地镜像仓库</p>\n</li>\n<li><p>docker commit</p>\n<p>创建某镜像的副本，成为新的容器</p>\n</li>\n<li><p>docker pull</p>\n<p>下载镜像</p>\n</li>\n<li><p>docker research xxx</p>\n<p>搜索镜像</p>\n</li>\n<li><p>docker   rmi </p>\n<p>删除镜像</p>\n</li>\n<li><p>创建镜像两种方式</p>\n<ol>\n<li><p>通过进入容器进行创建（<strong>实际上是创建文件的副本</strong>）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">runoob@runoob:~$ docker commit -m&#x3D;&quot;has update&quot; -a&#x3D;&quot;runoob&quot; e218edb10161 runoob&#x2F;ubuntu:v2\nsha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</code></pre>\n</li>\n<li><p><strong>通过DockerFile进行创建</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">runoob@runoob:~$ docker build -t runoob&#x2F;centos:6.7 .\nSending build context to Docker daemon 17.92 kB\nStep 1 : FROM centos:6.7\n ---&gt; d95b5ca17cc3\nStep 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;\n ---&gt; Using cache\n ---&gt; 0c92299c6f03\nStep 3 : RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd\n ---&gt; Using cache\n ---&gt; 0397ce2fbd0a\nStep 4 : RUN useradd runoob\n......</code></pre></li>\n</ol>\n</li>\n<li><p>docker tag  </p>\n<p>创建镜像标签</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">runoob@runoob:~$ docker tag 860c279d2fec runoob&#x2F;centos:dev</code></pre></li>\n</ul>\n<h3 id=\"仓库操作\"><a href=\"#仓库操作\" class=\"headerlink\" title=\"仓库操作\"></a>仓库操作</h3><ul>\n<li>docker login</li>\n<li>docker logout</li>\n<li>docker pull </li>\n<li>docker research</li>\n<li>docker  push</li>\n</ul>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><ul>\n<li><p>是什么？</p>\n<ul>\n<li>创建镜像的文本文件，用来指导创建镜像</li>\n<li>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</li>\n</ul>\n</li>\n<li><p>理解：</p>\n<ol>\n<li>创建方式：<ul>\n<li>创造镜像有两种方式，第一种是创建容器，在容器里面进行创建，第二种是dockerfile文本文件创建，而dockerfile创建的本质是使用脚本自动化的实现第一种模式。</li>\n</ul>\n</li>\n<li>为什么要创建镜像？<ul>\n<li>不同生产环境下具有不同的底层软件支持，所以要创建一个合适的镜像，而不是仅仅使用通用的，说白了就是<strong>搭建合适的具有相关功能的镜像</strong></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>创建流程</p>\n<ol>\n<li><p>docker从基础镜像运行一个容器</p>\n</li>\n<li><p>执行一条指令并对容器作出修改</p>\n</li>\n<li><p>执行类似docker commit的操作提交一个新的镜像层</p>\n</li>\n<li><p>docker再基于刚提交的镜像运行一个新容器</p>\n</li>\n<li><p>执行dockerfile中的下一条指令直到所有指令都执行完成</p>\n<p><strong>就像做花卷一样，一层一层的叠上去</strong></p>\n</li>\n</ol>\n</li>\n<li><p>关键字</p>\n<ul>\n<li>FROM                     基于那个基础镜像</li>\n<li>MAINTAINER        相关维护者的信息</li>\n<li>RUN                        执行的相关命令————-》等同于在终端执行的shell命令            <strong>（在docker build的时候执行）</strong></li>\n<li>EXPOSE                  对外的是什么接口</li>\n<li>WORDIR                 终端默认登录的工作目录</li>\n<li>USER                       指定该镜像以什么样的用户去执行，如果都不指定，默认是root</li>\n<li>ENV                           指定环境变量（WORKDIR $MY_PATH ）</li>\n<li>ADD                           将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY                       将宿主机目录下的文件拷贝进镜像</li>\n<li>VOLUME                    容器数据卷，用于数据保存和持久化工作</li>\n<li>CMD               Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换    <strong>（在docker run的时候执行）</strong></li>\n<li>ENTRYPOINT    类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的CMD命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序（<strong>未指定时为隐式声明</strong>）<ul>\n<li><strong>ENTRYPOINT 和  CMD配合使用，此时的CMD的任务不是执行命令，而是传递参数，并且cmd的参数会受docker run后面的参数影响</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建步骤</p>\n<ol>\n<li><p>编写Dockerfile文件（D一定要大写，注意保留字的使用）</p>\n</li>\n<li><p>docker build -t  新镜像名称：TAG .  （注意不要忘记后面的那个点）</p>\n</li>\n<li><p>docker run -it 新镜像名字:TAG </p>\n<ul>\n<li>这三部对应了上面的三张图</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Docker网络\"><a href=\"#Docker网络\" class=\"headerlink\" title=\"Docker网络\"></a>Docker网络</h2><ul>\n<li>是什么<ul>\n<li>就是容器之间的网络连接</li>\n</ul>\n</li>\n<li>作用<ul>\n<li>容器间的互联和通信以及端口映射</li>\n<li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li>\n</ul>\n</li>\n<li>模式<ul>\n<li>bridge<ul>\n<li>相当于NAT，每个容器通过Docker0这个虚拟的路由器分配得到各自的IP</li>\n</ul>\n</li>\n<li>host<ul>\n<li>容器和宿主机公用同一个IP地址</li>\n</ul>\n</li>\n<li>none<ul>\n<li>禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环)</li>\n</ul>\n</li>\n<li>container<ul>\n<li>container⽹络模式 新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 </li>\n<li><strong>就是和一个容器只共享网络</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>思考<ul>\n<li>bridge和host的区别<ul>\n<li>host模式中，因为容器的ip为宿主机Ip，所以在效率上更高，利用率跟高，bridge因为受到统一的安排，所以更好的管理</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","text":"Docker概述 是什么 是一款容器引擎，是一个用于开发，交付和运行应用程序的开放平台 作用 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 （应用和相关依赖环境一起打包到容器当中）解决...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Docker","slug":"Docker","count":1,"path":"api/categories/Docker.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Docker\"><span class=\"toc-text\">Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%85%E6%9E%90%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">浅析原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">容器操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">镜像操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">仓库操作</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Dockerfile\"><span class=\"toc-text\">Dockerfile</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">Docker网络</span></a></li></ol></li></ol>","author":{"name":"Hubert","slug":"blog-author","avatar":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xcbhhiq5j309y0dj3z9.jpg","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Net-OSPF之负载均衡","uid":"0df63ec25452415f0b2c8961aba42a85","slug":"net4","date":"2021-08-02T05:48:25.000Z","updated":"2022-05-05T02:42:45.974Z","comments":true,"path":"api/articles/net4.json","keywords":null,"cover":"https://wx2.sinaimg.cn/thumb300/008srJVCly1h1xbqv4c4hj30rs0dwdid.jpg","text":"这篇内容主要为了解，具体的功能技术实现自己并未动手操作，但是这篇内容最大的启示是ospf的功能不仅仅是AS内的发现和计算路由，还有其他功能，我们学习一种技术时不能局限于技术本身，而是要善用技术，这样才能真正理解相关技术，从而做到融会贯通 概述： 关于ospf： ​ OSPF(Op...","link":"","photos":[],"count_time":{"symbolsCount":972,"symbolsTime":"1 mins."},"categories":[{"name":"Net","slug":"Net","count":4,"path":"api/categories/Net.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xcbhhiq5j309y0dj3z9.jpg","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java-项目总结","uid":"52bf4c42f2d4889a67cc0b2c3cdd70c7","slug":"java5","date":"2021-05-11T05:48:25.000Z","updated":"2022-05-05T03:00:19.690Z","comments":true,"path":"api/articles/java5.json","keywords":null,"cover":"https://wx1.sinaimg.cn/mw1024/008srJVCly1h1xbqioae2j31gi0u0god.jpg","text":"SBMS项目笔记前置知识Servlet 是什么 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类 （一般开发都继承Httpservlet来实现） 作用 主要功能在于交互式地浏览和修改数据 理解： 在MVC三层架构中，...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":5,"path":"api/categories/Java.json"}],"tags":[],"author":{"name":"Hubert","slug":"blog-author","avatar":"https://wx3.sinaimg.cn/mw1024/008srJVCly1h1xcbhhiq5j309y0dj3z9.jpg","link":"/","description":"This is my own blog to     share my knowledge","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}