<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.1.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">TOP</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/CloudComputing/">CloudComputing</a></li><li><a class="category-link" href="/categories/K8s/">K8s</a></li><li><a class="category-link" href="/categories/Net/">Net</a></li><li><a class="category-link" href="/categories/docker/">docker</a></li><li><a class="category-link" href="/categories/java/">java</a></li><li><a class="category-link" href="/categories/other/">other</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="关于本人">
		                关于本人
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="生活分享">
		                生活分享
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(img/k8s/bg.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >K8s-基础</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li><strong>容器的本质是一种特殊的进程</strong> </li>
<li>容器的<strong>隔离</strong>和<strong>资源限制</strong>实现<ol>
<li><strong>namespace</strong><ul>
<li>相当于一个障眼法，利用linux的namespace机制实现隔离，而一个个docker实际上是一个个特殊的进程</li>
<li><strong>Namespace 技术实际上修改了应用进程看待整个计算机“视 图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。但对于宿主机来 说，这些被“隔离”了的进程跟其他进程并没有太大区别。</strong> </li>
<li>namespace的实现有很多类，比如PID，mount，network等方式（这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的 改变，一定是伴随着挂载操作（mount）才能生效。 ）</li>
</ul>
</li>
<li><strong>cgroups</strong><ul>
<li>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够 使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。 </li>
<li><strong>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织 在操作系统的 &#x2F;sys&#x2F;fs&#x2F;cgroup 路径下</strong> </li>
<li>在 &#x2F;sys&#x2F;fs&#x2F;cgroup目录下又很多资源，比如CPU，内存，如果我们在对应文件里面创建一个进程对应的文件，文件会自动创建一些目录，对响应的目录进行设置即可对资源进行限制，最后在将进程的PID写入task文件即可</li>
</ul>
</li>
<li><strong>容器的文件系统通过chroot进行改变挂载根目录实现</strong>（还不是特别懂）</li>
</ol>
</li>
<li>容器的安全问题<ul>
<li>在生产环境中，没有人敢把运行在物理机上的 Linux 容器直接暴露到公网上。因为本质来讲就是一个进程，公用同一个内核，所以安全性不高。</li>
</ul>
</li>
</ul>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>Kubernetes 是一个容器的编排工具 <strong>（用来管理和编排容器的）</strong>可以理解为云计算的操作系统</li>
</ul>
<h3 id="浅析K8s"><a href="#浅析K8s" class="headerlink" title="浅析K8s"></a>浅析K8s</h3><ul>
<li>技术本质：<ul>
<li><strong>容器本身没有价值，有价值的是“容器编排</strong> ，容器本身是一个底层技术，解决了应用打包这个问题，但是技术要落地到应用，要落地到Pass平台，所以如何利用容器进行商业化的应用才是真正的价值。而容器编排技术正是Pass落地的关键。</li>
</ul>
</li>
<li>核心特点：<ul>
<li>容器编排技术有很多，比如Docker Swarm 和 Mesos ，他们都能达到容器编排的目的，但是他们编排技术的出发点不同， Swarm是以docker为核心进行开发，而K8s是借鉴了谷歌的Brog项目，从顶层开始设计，docker仅仅是设计中的一部分，，Kubernetes 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各 种关系，并且为将来支持更多种类的关系留有余地。 而不仅仅是围绕着docker进行发展。</li>
</ul>
</li>
<li>价值：<ul>
<li>Kubernetes 项目为用户提供的不仅限于一个工具。它真正的价值，乃在于提供 了<strong>一套基于容器构建分布式系统的基础依赖</strong>。</li>
</ul>
</li>
</ul>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul>
<li><p><strong>master</strong>：主控节点 </p>
<ul>
<li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储 </li>
<li>scheduler：节点的调度，选择node节点应用部署</li>
<li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li>
<li>etcd：存储系统，用于保存集群中的相关数据</li>
</ul>
</li>
<li><p><strong>Work node</strong>：工作节点 </p>
<ul>
<li>Kubelet：master派到node节点代表，管理本机容器 <ul>
<li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li>
<li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li>
</ul>
</li>
<li>kube-proxy：提供网络代理，负载均衡等操作</li>
</ul>
</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3></li>
<li><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3></li>
<li><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3></li>
<li><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3></li>
<li><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3></li>
<li><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3></li>
<li><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3></li>
<li><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3></li>
</ul>
<h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><h3 id="搭建方式"><a href="#搭建方式" class="headerlink" title="搭建方式"></a>搭建方式</h3><ul>
<li>单master集群</li>
<li>多master集群</li>
</ul>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><ul>
<li><p>Kubeadm</p>
<blockquote>
<ul>
<li>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署： <ul>
<li>创建一个Master 节点kubeadm init</li>
<li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li>
</ul>
</li>
<li>原理：<ul>
<li>把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>二进制搭建</p>
<blockquote>
<ul>
<li><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p>
<p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><p>kubectl</p>
<ul>
<li>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署</li>
</ul>
<p>YAMl</p>
<ul>
<li>YAML文件：就是资源清单文件，用于资源编排 </li>
<li>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。</li>
</ul>
<h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><ul>
<li><p>编写YAML文件</p>
<ul>
<li><p>YAML文件本质上是一个配置文件，用来把容器的定义、参数、配置，统统记录在一个 YAML 文件中 ，对于K8s而言，YAML是API Object </p>
</li>
<li><p>具体格式：</p>
<ul>
<li><p>主要分为四大部分</p>
<ul>
<li>apiVersion   <strong>api版本</strong></li>
<li>kind              <strong>API对象种类</strong></li>
<li>metadata    <strong>对象标识数据</strong></li>
<li>spec              <strong>对象功能描述</strong></li>
</ul>
</li>
<li><p>&#96;&#96;&#96;yaml<br>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: nginx-deployment<br>spec:<br>  selector:<br>matchLabels:<br>  app: nginx<br>  replicas: 2<br>  template:<br>metadata:<br>  labels:<br>    app: nginx<br>  spec:<br>containers:<br>  - name: nginx<br>  image: nginx:1.7.9<br>  ports:<br>    - containerPort: 80</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 相关命令</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    $ kubectl create -f nginx-deployment.yaml       //运行YAML文件</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>&#96;&#96;&#96;java<br>$ kubectl get pods -l app&#x3D;nginx &#x2F;&#x2F;查看运行的pod</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  kubectl describe pod nginx-deployment-67594d6bf6-9gdvr //查看对象的详细信息</span><br><span class="line">  //其中的events记录了操作pod的重要事件，经常用于debug</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Pod-1"><a href="#Pod-1" class="headerlink" title="Pod"></a>Pod</h3><ul>
<li><p>是什么</p>
<ul>
<li>是k8s的最小的单位级，里面通过有单个或者多个容器构成，<strong>Pod是它们的逻辑主机</strong>，Pod包含业务相关的多个应用容器。</li>
</ul>
</li>
<li><p>实现原理</p>
<ul>
<li><p>pod本质上是一个<strong>逻辑上的集合体</strong>，并不是具体使用相关隔离和限制技术创建的一个空间</p>
</li>
<li><p>实现逻辑体的原理：</p>
<ul>
<li>共享网络命名空间（networkname space）<ul>
<li><strong>在pod中，不同的容器间属于对等关系，而不是从属关系，所以所有的容器只要共享Infra容器的网络命名空间即可</strong></li>
<li>其中Infra容器是永远处于暂停状态的特殊容器，和pod声明周期进行了绑定</li>
</ul>
</li>
<li>共享存储卷<ul>
<li>在创建pod的时候声明volume即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么是pod而不是容器</p>
<ul>
<li>pod的存在主要是让几个紧密连接的几个容器之间共享资源 <strong>（进程间存在亲密性）</strong>如果以容器为单位则管理开销很大</li>
<li><strong>容器的设计模式</strong>（pod设计的核心思想！！！）<ul>
<li>理解：相当于设计一个组合拳，用来解决单个容器难以解决的问题 </li>
<li>sidecar模式：sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进 程（主容器）之外的工作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>pod设计的核心思想</strong>：</p>
<ul>
<li>pod的本质设计<strong>是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用 户程序。</strong> </li>
<li>是<strong>一种传统应用架构到微服务架构的一种过渡</strong><ul>
<li>应用从物理机到虚拟机，因为只是底层资源发生了池化，所以迁移的架构变化不大，但是在云原生时代，不能把容器看成一个更加轻量化的虚拟机，因为容器的本质就是一个进程，而虚拟机理往往包含了多个进程，所以此阶段应用的上云不能只是套模板，而是根据容器的特点进行设计，而不仅仅是将虚拟机装进容器。而pod可以理解为云原生的虚拟机</li>
</ul>
</li>
</ul>
</li>
<li><p>pod相关属性</p>
<ul>
<li><p>apiserver：</p>
</li>
<li><p>kind</p>
</li>
<li><p>metadata</p>
</li>
<li><p>spec：</p>
<ul>
<li>NodeSelector：是一个供用户将 Pod 与 Node 进行绑定的字段 </li>
<li>NodeName：一旦 Pod 的这个字段被赋值，Kubernetes 项目就会被认为这个 Pod 已经经过了调 度，调度的结果就是赋值的节点名字。 </li>
<li>HostAliases：定义了 Pod 的 hosts 文件（比如 &#x2F;etc&#x2F;hosts）里的内容 </li>
<li>shareProcessNamespace&#x3D;true： 容器之间共享相关命名空间</li>
<li>hostNetwork: true    hostIPC: true    hostPID: true    容器共享宿主机的 Namespace </li>
<li>Init Container ：</li>
<li>Container ：</li>
<li>name：</li>
<li>image</li>
<li>port</li>
<li>ImagePullPolicy ：它定义了镜像拉取的策略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- IfNotPresent：默认值，镜像在宿主机上不存在才拉取</span><br><span class="line">- Always：每次创建Pod都会重新拉取一次镜像</span><br><span class="line">- Never：Pod永远不会主动拉取这个镜像</span><br></pre></td></tr></table></figure>

<ul>
<li>lifecycle: <ul>
<li>postStart:  在容器启动后，立刻执行一个指定的操作 （不保证严格顺序）</li>
<li>preStop:  容器被杀死之前 ，立刻执行一个指定的操作 （preStop 操作的执行，是同步的）</li>
</ul>
</li>
</ul>
</li>
<li><p>status：（pod的状态，声明周期）</p>
<ul>
<li>phase ：<strong>（pod的当前状态）</strong><ul>
<li>Pending：这个状态意味着，Pod 的 YAML 文件已经提交给了 Kubernetes，API 对象已经被 创建并保存在 Etcd 当中。但是，这个 Pod 里有些容器因为某种原因而不能被顺利创建。比 如，调度不成功。 </li>
<li>Running。这个状态下，Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创 建成功，并且至少有一个正在运行中。 </li>
<li>Succeeded。这个状态意味着，Pod 里的所有容器都正常运行完毕，并且已经退出了。这种情 况在运行一次性任务时最为常见。 </li>
<li>Failed。这个状态下，Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状 态的出现，意味着你得想办法 Debug 这个容器的应用，比如查看 Pod 的 Events 和日志。 </li>
<li>Unknown。这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kubeapiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题。</li>
</ul>
</li>
<li>Conditions ：<strong>（描述造成当前 Status 的具体原因）</strong><ul>
<li>PodScheduled</li>
<li>Ready </li>
<li>Initialized</li>
<li>Unschedulable。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Podpreset</p>
<ul>
<li>是什么？<ul>
<li>就是事先定义好的pod，用来追加新建pod的内容，</li>
</ul>
</li>
<li>目的：<ul>
<li>减少新建pod的复杂度，批量化修改pod</li>
</ul>
</li>
<li>注意：<ul>
<li>它只能修改新建的pod的内容，而对控制器内容无法改变</li>
<li>当有多个podpreset时，新建的pod会将他们的字段进行融合使用</li>
</ul>
</li>
</ul>
</li>
<li><p>Pod资源调度限制</p>
<ul>
<li>request：表示调度所需的资源</li>
<li>limits：表示最大所占用的资源<ul>
<li>只有满足request的要求才能被调用</li>
</ul>
</li>
</ul>
</li>
<li><p>Pod的重启策略（恢复机制）</p>
<ul>
<li>Always：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】</li>
<li>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</li>
<li>Never：当容器终止退出，从不重启容器 【批量任务】</li>
</ul>
</li>
<li><p>Pod的健康检查</p>
<ul>
<li>通过探针技术<ul>
<li>探针种类<ul>
<li>livenessProbe</li>
<li>指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略决定未来。如果容器不提供存活探针， 则默认状态为 Success。</li>
<li>readinessProbe<ul>
<li>指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 Failure。 如果容器不提供就绪态探针，则默认状态为 Success。</li>
</ul>
</li>
<li>startupProbe<ul>
<li>指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其 重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 Success。</li>
</ul>
</li>
</ul>
</li>
<li>检测结果<ul>
<li>Success（成功）<ul>
<li>容器通过了诊断。</li>
</ul>
</li>
<li>Failure（失败）<ul>
<li>容器未通过诊断。</li>
</ul>
</li>
<li>Unknown（未知）<ul>
<li>诊断失败，因此不会采取任何行动。</li>
</ul>
</li>
</ul>
</li>
<li>探针的检查机制<ul>
<li>exec<ul>
<li>在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li>
</ul>
</li>
<li>grpc<ul>
<li>使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 “SERVING”，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 “GRPCContainerProbe” 特性门控时才能使用。</li>
</ul>
</li>
<li>httpGet<ul>
<li>对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</li>
</ul>
</li>
<li>tcpSocket<ul>
<li>对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Pod的资源调度策略</p>
<ul>
<li><p>根据资源的调度限制request进行调配</p>
</li>
<li><p>根据nodeSelector标签进行调度</p>
</li>
<li><p>根据点亲和性 <strong>nodeAffinity</strong> </p>
<ul>
<li>硬亲和性：约束条件必须满足</li>
<li>软亲和性：尝试满足，不保证</li>
</ul>
</li>
</ul>
</li>
<li><p>污点和污点容忍</p>
<ul>
<li><p>概述：</p>
<p>在调度pod的时候，有request，nodeSelector和nodeAffinity对nod的策略调度，但是pod最终归属是在某个node节点上，所以也可以通过对node的属性进行相关设置，从而侧面实现pod的调度</p>
<ul>
<li>Taint 污点：节点不做普通分配调度，是节点属性</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>最大的应用就是master节点，因为里面不能有pod</li>
<li>专用节点【限制ip】</li>
<li>配置特定硬件的节点【固态硬盘】</li>
<li>基于Taint驱逐【在node1不放，在node2放】</li>
</ul>
</li>
<li><p>相关操作</p>
<ol>
<li><p>查看污点情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node k8smaster | grep Taint</span><br></pre></td></tr></table></figure>

<ul>
<li>NoSchedule：一定不被调度</li>
<li>PreferNoSchedule：尽量不被调度【也有被调度的几率】</li>
<li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li>
</ul>
</li>
<li><p>如何对node添加污点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint node [node] key=value:污点的三个值</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除污点</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint node k8snode1 env_role:NoSchedule-</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li><p>是什么</p>
<p>Controller是在集群上<strong>管理和运行pod的对象</strong> </p>
</li>
<li><p>Pod和Controller的关系</p>
<ul>
<li>controller就是pod的控制器，用来控制pod的相关功能，比如回滚，    弹性伸缩等等</li>
<li>Pod 和 Controller之间是通过label标签来建立关系，同时Controller又被称为控制器工作负载</li>
</ul>
</li>
<li><p>种类</p>
<ul>
<li><p>deployment</p>
</li>
<li><p>Statefulset</p>
</li>
<li><p>DaemonSet</p>
</li>
<li><p>Job</p>
</li>
<li><p>CronJob</p>
</li>
<li><p>Replication Controller</p>
</li>
<li><p>Replica Set</p>
</li>
</ul>
</li>
<li><p>Deployment</p>
<ul>
<li><p>概述</p>
<ul>
<li>是controller的一种</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li><p>pod的<strong>水平扩展&#x2F;收缩</strong>和<strong>滚动更新</strong></p>
</li>
<li><p>Deployment控制器可以部署<strong>无状态应用</strong></p>
</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li>Deployment控制着RS的版本，而RS控制着Pod副本的数量</li>
<li><strong>水平扩展&#x2F;收缩：</strong>RS控制</li>
<li><strong>滚动更新：</strong>两个RS交替更替</li>
</ul>
</li>
</ul>
</li>
<li><p>Statefulset</p>
<ul>
<li>主要用于部署<strong>有状态的pod</strong></li>
<li>适合StatefulSet的业务包括数据库服务MySQL 和 PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务</li>
</ul>
</li>
<li><p>DaemonSet</p>
<ul>
<li>DaemonSet 即后台支撑型服务，主要是用来部署守护进程 </li>
<li>典型的后台支撑型服务包括：存储、日志和监控等。在每个节点上支撑K8S集群运行的服务。</li>
</ul>
</li>
<li><p>Job</p>
<ul>
<li>Job也即一次性任务 </li>
<li>Job管理的Pod根据用户的设置把任务成功完成就自动退出了。</li>
</ul>
</li>
<li><p>CronJob</p>
<ul>
<li>定时任务</li>
</ul>
</li>
<li><p>Replication Controller</p>
<ul>
<li>RC是K8S中较早期的技术概念，只适用于长期伺服型的业务类型，比如控制Pod提供高可用的Web服务。</li>
</ul>
</li>
<li><p>Replica Set</p>
<ul>
<li>Replica Set 检查 RS，也就是副本集。RS是新一代的RC，提供同样高可用能力，区别主要在于RS后来居上，能够支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数来使用</li>
</ul>
</li>
</ul>
<h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><ul>
<li><p>是什么</p>
<p>是一个为客户端访问pod的一个对象</p>
</li>
<li><p>作用</p>
<ul>
<li><p>要稳定地提供服务需要<strong>服务发现</strong>和<strong>负载均衡能力</strong> </p>
</li>
<li><p>服务发现</p>
<ul>
<li>因为Pod每次创建都对应一个IP地址，而这个IP地址是短暂的，每次随着Pod的更新都会变化，假设当我们的前端页面有多个Pod时候，同时后端也多个Pod，这个时候，他们之间的相互访问，就需要通过注册中心，拿到Pod的IP地址，然后去访问对应的Pod</li>
</ul>
</li>
<li><p>负载均衡</p>
<ul>
<li>页面前端的Pod访问到后端的Pod，中间会通过Service一层，而Service在这里还能做负载均衡，负载均衡的策略有很多种实现策略，例如：<ul>
<li>随机</li>
<li>轮询</li>
<li>响应比</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Service常用类型有三种</p>
<ul>
<li>ClusterIp：集群内部访问</li>
<li>NodePort：对外访问应用使用</li>
<li>LoadBalancer：对外访问应用使用，公有云</li>
</ul>
</li>
</ul>
<h3 id="声明式API"><a href="#声明式API" class="headerlink" title="声明式API"></a>声明式API</h3><ul>
<li><p>个人理解：</p>
<ul>
<li>声明式API是K8s的核心，因为互联网的规模很大，仅仅使用K8s内部的编排对象可能不够用，所以要自己编写API对象和编排对象进行适合业务的资源控制，而这种功能的实现依靠的是K8s的API插拔机制，可以理解为在不修改K8s的基础上进行功能的扩展，所以我们编写API对象和编排对象都是通过声明式API进行编写，而通过API插拔机制进行实现，而这也是<strong>k8s使用者到k8s玩家的一个重要过渡</strong></li>
</ul>
</li>
<li><p>请求</p>
<ul>
<li>响应式</li>
<li><strong>声明式</strong></li>
</ul>
</li>
<li><p>是什么？</p>
<ul>
<li>是 kubectl apply 命令。 YAML只是个配置文件</li>
<li>kubectl apply，执行了一个对原有 API 对象的 PATCH 操 作。 </li>
<li>请求分类：<ul>
<li>响应命令式请求 ：一次只能处理一个写请求，否则会有产生冲突的可能 （kubectl replace ）</li>
<li><strong>声明式请求</strong> ：一次能处理多个写操作，并且具备 Merge 能力。 （kubectl apply）</li>
</ul>
</li>
</ul>
</li>
<li><p>声明式 API 的设计 </p>
<ul>
<li>API 对象在 Etcd 里的完整资源路径 <ul>
<li>Group（API 组） </li>
<li>Version（API 版本） </li>
<li>Resource（API 资源类型）</li>
</ul>
</li>
</ul>
</li>
<li><p>声明式 API 的创建流程</p>
<ol>
<li>创建 CronJob 的 POST 请求之后，我们编写的 YAML 的信息就被提交给 了 APIServer。 </li>
<li>过滤这个请求，并完成一些前置性的工作，比如授权、超时 处理、审计等。 </li>
<li>进入 MUX 和 Routes 流程 <ul>
<li>MUX 和 Routes 是 APIServer 完成 URL 和 Handler 绑定的场所 <ul>
<li>Handler就是完成对象的绑定<ul>
<li>Kubernetes 对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项 目里<strong>找到 CronJob 对象的定义</strong> <ul>
<li>Kubernetes 会匹配 API 对象的组 </li>
<li>Kubernetes 会进一步匹配到 API 对象的版本号 </li>
<li>Kubernetes 会匹配 API 对象的资源类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>根据这个 CronJob 类型定义，使用用户提交的 YAML 文件里的字段，创建一个 CronJob 对象。 <ul>
<li>进行一个 Convert 工作 <ul>
<li>把用户提交的 YAML 文件，转换 成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。这样用户提 交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理了。</li>
</ul>
</li>
<li>APIServer 会先后进行 Admission() 和 Validation() 操作 <ul>
<li>Admission()</li>
<li>Validation()  <ul>
<li>Validation，则负责验证这个对象里的各个字段是否合法。这个被验证过的 API 对象，都保 存在了 APIServer 里一个叫作 Registry 的数据结构中。也就是说，只要一个 API 对象的定义能 在 Registry 里查到，它就是一个有效的 Kubernetes API 对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调 用 Etcd 的 API 把它保存起来。</li>
</ol>
</li>
<li><p><strong>API 插件机制：CRD</strong> </p>
<ul>
<li><p>是什么？</p>
<ul>
<li>自定义 API 资源 </li>
<li>CRD 的全称是 Custom Resource Definition。顾名思义，它指的就是，允许用户在 Kubernetes 中添加一个跟 Pod、Node 类似的、新的 API 资源类型</li>
</ul>
</li>
<li><p>个人理解：</p>
<ul>
<li>尽管K8s自带的一些资源定义已经够用，但是在具体的使用上，需要量身定制一些“自定义资源”，也就是CR（用户自定义资源），而CR的定义就是我们要的的CRD</li>
</ul>
</li>
<li><p>如何编写：</p>
<ol>
<li><p><strong>创建API对象：</strong></p>
<ul>
<li><ul>
<li><ol>
<li><p>进行定义：</p>
<ul>
<li><ol>
<li><p>在K8s进行宏观的定义</p>
<ul>
<li>编写YAML文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">networks.samplecrd.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">group:</span> <span class="string">samplecrd.k8s.io</span></span><br><span class="line"> <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"> <span class="attr">names:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line"> <span class="attr">plural:</span> <span class="string">networks</span></span><br><span class="line"> <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>用Go语言进行微观的定义</p>
<ul>
<li>用GO创建相关文件夹<ul>
<li>pkg&#x2F;apis&#x2F;samplecrd 目录下创建了一个 register.go 文件，用来放置后面要用到的 全局变量 </li>
<li>pkg&#x2F;apis&#x2F;samplecrd 目录下添加一个 doc.go 文件 ，起到的是全局的代码生成控制的作用，所以也被称 为 Global Tags。 </li>
<li>pkg&#x2F;apis&#x2F;samplecrd 目录下添加一个 添加 types.go 文件。顾名思义，它的作用就是定义一个 Network 类型到底有 哪些字段（比如，spec 字段里的内容） <ul>
<li>除了定义 Network 类型，你还需要定义一个 NetworkList 类型</li>
</ul>
</li>
<li>编写的一个 pkg&#x2F;apis&#x2F;samplecrd&#x2F;v1&#x2F;register.go 文件 <ul>
<li>registry 的作用就是注册一个类型 （Type）到 APIServer 中。而这个内层目录下的 register.go，就是这个注册流程要使用的代 码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>使用 Kubernetes 提供的代码生成工具，为上面定义的 Network 资源类型自动 生成 clientset、informer 和 lister</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为这个 API 对象编写一个自定义控制器（Custom Controller）</strong>    这一部分要结合具体的场景进行深刻的认识</p>
<ul>
<li>编写 main 函数 </li>
<li>main 函数的主要工作就是，定义并初始化一个自定义控制器（Custom Controller），然后启 动它。 <ul>
<li>第一步：main 函数根据我提供的 Master 配置（APIServer 的地址端口和 kubeconfig 的路 径），创建一个 Kubernetes 的 client（kubeClient）和 Network 对象的 client（networkClient）。 </li>
<li>第二步：main 函数为 Network 对象创建一个叫作 InformerFactory（即： networkInformerFactory）的工厂，并使用它生成一个 Network 对象的 Informer，传递给控 制器。 </li>
<li>第三步：main 函数启动上述的 Informer，然后执行 controller.Run，启动自定义控制器。</li>
</ul>
</li>
<li>编写自定义控制器的定义 </li>
<li>及编写控制器里的业务逻辑</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Istio 项目</p>
<ul>
<li><p>是什么</p>
<ul>
<li>一个基于 Kubernetes 项目的微服务治理框架</li>
</ul>
</li>
<li><p>核心</p>
<ul>
<li>Envoy 容器 （使用的sidecar模式）<ul>
<li>作用：Envoy 容器就 能够通过配置 Pod 里的 iptables 规则，把整个 Pod 的进出流量接管下来。 </li>
<li>原理：<ul>
<li>就是在用户创建pod的时候自动添加相关envoy的信息，进而创建envoy<ul>
<li>实现原理：<ul>
<li>首先Istio 会将这个 Envoy 容器本身的定义，以 ConfigMap 的方式保存在 Kubernetes 当 中。</li>
<li>然后通过 Initializer将Envoy的信息加入到pod的API当中<ul>
<li>该步骤的实现原理：<ul>
<li>Istio 将一个编写好的 Initializer，作为一个 Pod 部署在 Kubernetes 中。而这个pod的基础镜像是个自定义的控制器，控制器的作用就是为新建的pod打上标签，而这个标签就是在ConfigMap保存的内容</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li><p>运行原理：</p>
<ul>
<li>Istio 的控制层（Control Plane）里的 Pilot 组件，就能够通过调用每个 Envoy 容器的 API，对这个 Envoy 代理进行配置，从而实现微服务治理。</li>
</ul>
</li>
<li><p>Dynamic Admission Control。 （动态准入控制）</p>
<ul>
<li><p>背景：</p>
<p>k8s在请求apiserver后会进行初始化，“初始化”操作的实现，借助的是一个叫作 Admission 的功能 （就是一段功能性代码选择性地被编译进 APIServer 中，在 API 对象创建之后会被立刻调用到。）但是如果要更改Admission的配置要重新编译apiserver，开销很大，所以，Kubernetes 项目为我们额外提供了一种“热插拔”式的 Admission 机制，它就是 Dynamic Admission Control，也叫作：Initializer。 </p>
</li>
<li><p>是什么</p>
<ul>
<li>也叫Initializer ，<strong>是热插拔的Admission</strong></li>
</ul>
</li>
<li><p>依赖：</p>
<ul>
<li>在 Initializer 更新用户的 Pod 对象的时候，必须使用 <strong>PATCH API</strong> 来完成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2021/08/26/K8s/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2021/08/26/K8s/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
